{"ast":null,"code":"// src/utils/custom-errors.ts\nvar PinataError = class extends Error {\n  constructor(message, statusCode, details) {\n    super(message);\n    this.statusCode = statusCode;\n    this.details = details;\n    this.name = \"PinataError\";\n  }\n};\nvar NetworkError = class extends PinataError {\n  constructor(message, statusCode, details) {\n    super(message, statusCode, details);\n    this.name = \"NetworkError\";\n  }\n};\nvar AuthenticationError = class extends PinataError {\n  constructor(message, statusCode, details) {\n    super(message, statusCode, details);\n    this.name = \"AuthenticationError\";\n  }\n};\nvar ValidationError = class extends PinataError {\n  constructor(message, details) {\n    super(message, void 0, details);\n    this.name = \"ValidationError\";\n  }\n};\n\n// src/core/authentication/testAuthentication.ts\nvar testAuthentication = async config => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/testAuthentication\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/data/testAuthentication\", {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing authentication: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while testing authentication\");\n  }\n};\n\n// src/core/pinning/file.ts\nvar uploadFile = async (config, file, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const jwt = options?.keys || config.pinataJwt;\n  const data = new FormData();\n  data.append(\"file\", file, file.name);\n  data.append(\"pinataOptions\", JSON.stringify({\n    cidVersion: options?.cidVersion,\n    groupId: options?.groupId\n  }));\n  data.append(\"pinataMetadata\", JSON.stringify({\n    name: options?.metadata ? options.metadata.name : file.name,\n    keyvalues: options?.metadata?.keyValues\n  }));\n  const headers = {\n    Authorization: `Bearer ${jwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/file\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/pinFileToIPFS\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error uploading file: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading the file\");\n  }\n};\n\n// src/core/pinning/fileArray.ts\nvar uploadFileArray = async (config, files, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const folder = options?.metadata?.name ?? \"folder_from_sdk\";\n  const data = new FormData();\n  for (const file of Array.from(files)) {\n    data.append(\"file\", file, `${folder}/${file.name}`);\n  }\n  data.append(\"pinataMetadata\", JSON.stringify({\n    name: folder,\n    keyvalues: options?.metadata?.keyValues\n  }));\n  data.append(\"pinataOptions\", JSON.stringify({\n    cidVersion: options?.cidVersion,\n    groupId: options?.groupId\n  }));\n  const headers = {\n    Authorization: `Bearer ${jwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/fileArray\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/pinFileToIPFS\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing fileArray: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading an array of files\");\n  }\n};\n\n// src/core/pinning/base64.ts\nvar uploadBase64 = async (config, base64String, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const name = options?.metadata?.name ? options?.metadata?.name : \"base64 string\";\n  const buffer = Buffer.from(base64String, \"base64\");\n  const blob = new Blob([buffer]);\n  const data = new FormData();\n  data.append(\"file\", blob, name);\n  data.append(\"pinataOptions\", JSON.stringify({\n    cidVersion: options?.cidVersion,\n    groupId: options?.groupId\n  }));\n  data.append(\"pinataMetadata\", JSON.stringify({\n    name,\n    keyvalues: options?.metadata?.keyValues\n  }));\n  const headers = {\n    Authorization: `Bearer ${jwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/base64\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/pinFileToIPFS\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing base64: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while trying to upload base64\");\n  }\n};\n\n// src/core/pinning/url.ts\nvar uploadUrl = async (config, url, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const data = new FormData();\n  const stream = await fetch(url);\n  if (!stream.ok) {\n    const errorData = await stream.json();\n    throw new NetworkError(`HTTP error! status: ${stream.status}`, stream.status, errorData);\n  }\n  const arrayBuffer = await stream.arrayBuffer();\n  const blob = new Blob([arrayBuffer]);\n  const name = options?.metadata?.name ?? \"url_upload\";\n  const file = new File([blob], name);\n  data.append(\"file\", file, name);\n  data.append(\"pinataOptions\", JSON.stringify({\n    cidVersion: options?.cidVersion,\n    groupId: options?.groupId\n  }));\n  data.append(\"pinataMetadata\", JSON.stringify({\n    name,\n    keyvalues: options?.metadata?.keyValues\n  }));\n  const headers = {\n    Authorization: `Bearer ${jwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/url\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/pinFileToIPFS\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing url: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading by url\");\n  }\n};\n\n// src/core/pinning/json.ts\nvar uploadJson = async (config, jsonData, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const data = JSON.stringify({\n    pinataContent: jsonData,\n    pinataOptions: {\n      cidVersion: options?.cidVersion,\n      groupId: options?.groupId\n    },\n    pinataMetadata: {\n      name: options?.metadata ? options.metadata.name : \"json\",\n      keyvalues: options?.metadata?.keyValues\n    }\n  });\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${jwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/json\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/pinJSONToIPFS\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing json: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while uploading json\");\n  }\n};\n\n// src/core/pinning/cid.ts\nvar uploadCid = async (config, cid, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const jwt = options?.keys || config?.pinataJwt;\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${jwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/cid\";\n  const data = JSON.stringify({\n    hashToPin: cid,\n    pinataMetadata: {\n      name: options?.metadata ? options?.metadata?.name : cid,\n      keyvalues: options?.metadata?.keyValues\n    },\n    pinataOptions: {\n      hostNodes: options?.peerAddresses ? options.peerAddresses : \"\",\n      groupId: options?.groupId\n    }\n  });\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/pinByHash\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing cid: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while pinning by CID\");\n  }\n};\n\n// src/core/pinning/unpin.ts\nvar wait = milliseconds => {\n  return new Promise(resolve => {\n    setTimeout(resolve, milliseconds);\n  });\n};\nvar unpinFile = async (config, files) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const responses = [];\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/unpin\";\n  for (const hash of files) {\n    try {\n      const response = await fetch(`https://api.pinata.cloud/pinning/unpin/${hash}`, {\n        method: \"DELETE\",\n        headers\n      });\n      await wait(300);\n      if (!response.ok) {\n        const errorData = await response.json();\n        if (response.status === 401) {\n          throw new AuthenticationError(\"Authentication failed\", response.status, errorData);\n        }\n        throw new NetworkError(`HTTP error! status: ${response.status}`, response.status, errorData);\n      }\n      const result = await response.text();\n      responses.push({\n        hash,\n        status: result\n      });\n    } catch (error) {\n      let errorMessage;\n      if (error instanceof PinataError) {\n        errorMessage = error.message;\n      } else if (error instanceof Error) {\n        errorMessage = `Error unpinning file ${hash}: ${error.message}`;\n      } else {\n        errorMessage = `An unknown error occurred while unpinning file ${hash}`;\n      }\n      responses.push({\n        hash,\n        status: errorMessage\n      });\n    }\n  }\n  return responses;\n};\n\n// src/core/data/listFiles.ts\nvar listFiles = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const params = new URLSearchParams({\n    includesCount: \"false\"\n  });\n  if (options) {\n    const {\n      cid,\n      pinStart,\n      pinEnd,\n      pinSizeMin,\n      pinSizeMax,\n      pageLimit,\n      pageOffset,\n      name,\n      key,\n      value,\n      operator,\n      groupId\n    } = options;\n    if (cid) params.append(\"cid\", cid);\n    if (pinStart) params.append(\"pinStart\", pinStart);\n    if (pinEnd) params.append(\"pinEnd\", pinEnd);\n    if (pinSizeMin) params.append(\"pinSizeMin\", pinSizeMin.toString());\n    if (pinSizeMax) params.append(\"pinSizeMax\", pinSizeMax.toString());\n    if (pageLimit) params.append(\"pageLimit\", pageLimit.toString());\n    if (pageOffset) params.append(\"pageOffset\", pageOffset.toString());\n    if (groupId) params.append(\"groupId\", groupId);\n    if (name) params.append(\"metadata[name]\", name);\n    if (key && value) {\n      const keyValueParam = JSON.stringify({\n        [key]: {\n          value,\n          op: operator || \"eq\"\n        }\n      });\n      params.append(\"metadata[keyvalues]\", keyValueParam);\n    }\n  }\n  const url = `https://api.pinata.cloud/data/pinList?status=pinned&${params.toString()}`;\n  try {\n    const headers = {\n      Authorization: `Bearer ${config?.pinataJwt}`\n    };\n    if (config.customHeaders) {\n      Object.assign(headers, config.customHeaders);\n    }\n    headers[\"Source\"] = headers[\"Source\"] || \"sdk/listFiles\";\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.rows;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing list files: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing files\");\n  }\n};\n\n// src/core/data/updateMetadata.ts\nvar updateMetadata = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const data = {\n    ipfsPinHash: options.cid,\n    name: options.name,\n    keyvalues: options.keyValues\n  };\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/updateMetadata\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/pinning/hashMetadata\", {\n      method: \"PUT\",\n      headers,\n      body: JSON.stringify(data)\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing updateMetadata: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while updating metadata\");\n  }\n};\n\n// src/utils/gateway-tools.ts\nvar isIPFSModule;\nasync function getIsIPFS() {\n  if (!isIPFSModule) {\n    isIPFSModule = await import(\"is-ipfs\");\n  }\n  return isIPFSModule;\n}\nasync function containsCID(input) {\n  if (typeof input !== \"string\") {\n    throw new Error(\"Input is not a string\");\n  }\n  const isIPFS = await getIsIPFS();\n  const startsWithCID = str => {\n    const parts = str.split(\"/\");\n    return isIPFS.cid(parts[0]) ? parts[0] : null;\n  };\n  const directCID = startsWithCID(input);\n  if (directCID) {\n    return {\n      containsCid: true,\n      cid: directCID\n    };\n  }\n  let url;\n  try {\n    url = new URL(input);\n  } catch (error) {\n    const parts = input.split(/\\/|\\?/);\n    for (const part of parts) {\n      const cid = startsWithCID(part);\n      if (cid) {\n        return {\n          containsCid: true,\n          cid\n        };\n      }\n    }\n    return {\n      containsCid: false,\n      cid: null\n    };\n  }\n  const subdomains = url.hostname.split(\".\");\n  for (const subdomain of subdomains) {\n    if (isIPFS.cid(subdomain)) {\n      return {\n        containsCid: true,\n        cid: subdomain\n      };\n    }\n  }\n  const pathParts = url.pathname.split(\"/\");\n  for (const part of pathParts) {\n    const cid = startsWithCID(part);\n    if (cid) {\n      return {\n        containsCid: true,\n        cid\n      };\n    }\n  }\n  return {\n    containsCid: false,\n    cid: null\n  };\n}\nasync function convertToDesiredGateway(sourceUrl, desiredGatewayPrefix) {\n  const results = await containsCID(sourceUrl);\n  if (results.containsCid !== true) {\n    throw new Error(\"url does not contain CID\");\n  }\n  if (!sourceUrl.startsWith(\"https\") && !sourceUrl.startsWith(\"ipfs://\")) {\n    return `${desiredGatewayPrefix}/ipfs/${sourceUrl}`;\n  }\n  const urlObj = new URL(sourceUrl);\n  const path = urlObj.pathname + urlObj.search + urlObj.hash;\n  if (sourceUrl.startsWith(`ipfs://${results.cid}`)) {\n    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;\n  }\n  if (sourceUrl.includes(`/ipfs/${results.cid}`)) {\n    return `${desiredGatewayPrefix}${path}`;\n  }\n  if (sourceUrl.includes(`/ipns/${results.cid}`)) {\n    return `${desiredGatewayPrefix}${path}`;\n  }\n  if (urlObj.hostname.includes(results.cid)) {\n    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;\n  }\n  throw new Error(\"unsupported URL pattern, please submit a github issue with the URL utilized\");\n}\n\n// src/core/gateway/getCid.ts\nvar getCid = async (config, cid) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  let data;\n  let newUrl;\n  newUrl = await convertToDesiredGateway(cid, config?.pinataGateway);\n  if (config?.pinataGatewayKey) {\n    newUrl = `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;\n  }\n  try {\n    const request = await fetch(newUrl, {\n      method: \"GET\",\n      headers: {\n        Source: \"sdk/getCid\"\n      }\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const contentType = request.headers.get(\"content-type\");\n    if (contentType?.includes(\"application/json\")) {\n      data = await request.json();\n    } else if (contentType?.includes(\"text/\")) {\n      data = await request.text();\n    } else {\n      data = await request.blob();\n    }\n    const res = {\n      data,\n      contentType\n    };\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing getCid: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while getting CID contents\");\n  }\n};\n\n// src/core/gateway/convertIPFSUrl.ts\nvar convertIPFSUrl = async (config, url) => {\n  let newUrl;\n  newUrl = await convertToDesiredGateway(url, config?.pinataGateway);\n  if (config?.pinataGatewayKey) {\n    `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;\n  }\n  return newUrl;\n};\n\n// src/core/data/pinJobs.ts\nvar pinJobs = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const params = new URLSearchParams({\n    includesCount: \"false\"\n  });\n  if (options) {\n    const {\n      ipfs_pin_hash: cid,\n      status,\n      sort,\n      limit,\n      offset\n    } = options;\n    if (cid) params.append(\"ipfs_pin_hash\", cid.toString());\n    if (status) params.append(\"status\", status.toString());\n    if (sort) params.append(\"sort\", sort.toString());\n    if (limit) params.append(\"limit\", limit.toString());\n    if (offset) params.append(\"offset\", offset.toString());\n  }\n  const url = `https://api.pinata.cloud/pinning/pinJobs?${params.toString()}`;\n  const headers = {\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/pinJobs\";\n  try {\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.rows;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing pinJobs: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing pin jobs\");\n  }\n};\n\n// src/core/data/pinnedFileUsage.ts\nvar pinnedFileCount = async config => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const url = \"https://api.pinata.cloud/data/userPinnedDataTotal\";\n  const headers = {\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/pinnedFileUsage\";\n  try {\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.pin_count;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing pinnedFileUsage: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while getting pinned file usage\");\n  }\n};\n\n// src/core/data/totalStorageUsage.ts\nvar totalStorageUsage = async config => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const url = \"https://api.pinata.cloud/data/userPinnedDataTotal\";\n  const headers = {\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/totalStorageUsage\";\n  try {\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.pin_size_total;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing totalStorageUsage: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while getting total storage usage\");\n  }\n};\n\n// src/core/keys/createKey.ts\nvar createKey = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/createKey\";\n  const data = JSON.stringify(options);\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/v3/pinata/keys\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing createKey: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while creating API key\");\n  }\n};\n\n// src/core/keys/listKeys.ts\nvar listKeys = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/listKeys\";\n  const params = new URLSearchParams();\n  if (options) {\n    const {\n      offset,\n      name,\n      revoked,\n      limitedUse,\n      exhausted\n    } = options;\n    if (offset) params.append(\"offset\", offset.toString());\n    if (revoked !== void 0) params.append(\"revoked\", revoked.toString());\n    if (limitedUse !== void 0) params.append(\"limitedUse\", limitedUse.toString());\n    if (exhausted !== void 0) params.append(\"exhausted\", exhausted.toString());\n    if (name) params.append(\"name\", name);\n  }\n  const url = `https://api.pinata.cloud/v3/pinata/keys?${params.toString()}`;\n  try {\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.keys;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing listKeys: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing API keys\");\n  }\n};\n\n// src/core/keys/revokeKeys.ts\nvar wait2 = milliseconds => {\n  return new Promise(resolve => {\n    setTimeout(resolve, milliseconds);\n  });\n};\nvar revokeKeys = async (config, keys) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/revokeKeys\";\n  const responses = [];\n  for (const key of keys) {\n    try {\n      const request = await fetch(`https://api.pinata.cloud/v3/pinata/keys/${key}`, {\n        method: \"PUT\",\n        headers\n      });\n      await wait2(300);\n      if (!request.ok) {\n        const errorData = await request.json();\n        if (request.status === 401) {\n          throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n        }\n        throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n      }\n      const result = await request.json();\n      responses.push({\n        key,\n        status: result\n      });\n    } catch (error) {\n      let errorMessage;\n      if (error instanceof PinataError) {\n        errorMessage = error.message;\n      } else if (error instanceof Error) {\n        errorMessage = `Error revoking key ${key}: ${error.message}`;\n      } else {\n        errorMessage = `An unknown error occurred while revoking key ${key}`;\n      }\n      responses.push({\n        key,\n        status: errorMessage\n      });\n    }\n  }\n  return responses;\n};\n\n// src/core/groups/createGroup.ts\nvar createGroup = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const data = JSON.stringify(options);\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/createGroup\";\n  try {\n    const request = await fetch(\"https://api.pinata.cloud/groups\", {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing createGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while creating a group\");\n  }\n};\n\n// src/core/groups/listGroups.ts\nvar listGroups = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/listGroups\";\n  const params = new URLSearchParams();\n  if (options) {\n    const {\n      offset,\n      nameContains,\n      limit\n    } = options;\n    if (offset) params.append(\"offset\", offset.toString());\n    if (nameContains !== void 0) params.append(\"nameContains\", nameContains.toString());\n    if (limit !== void 0) params.append(\"limit\", limit.toString());\n  }\n  const url = `https://api.pinata.cloud/groups?${params.toString()}`;\n  try {\n    const request = await fetch(url, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing listGroups: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while listing groups\");\n  }\n};\n\n// src/core/groups/getGroup.ts\nvar getGroup = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/getGroup\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/groups/${options.groupId}`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing getGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while getting info for a group\");\n  }\n};\n\n// src/core/groups/addToGroup.ts\nvar addToGroup = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const data = JSON.stringify({\n    cids: options.cids\n  });\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/addToGroup\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/groups/${options.groupId}/cids`, {\n      method: \"PUT\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing addToGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while adding CIDs to group\");\n  }\n};\n\n// src/core/groups/updateGroup.ts\nvar updateGroup = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const data = JSON.stringify({\n    name: options.name\n  });\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/updateGroup\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/groups/${options.groupId}`, {\n      method: \"PUT\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing updateGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while updating group\");\n  }\n};\n\n// src/core/groups/removeFromGroup.ts\nvar removeFromGroup = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/removeFromGroup\";\n  const data = JSON.stringify({\n    cids: options.cids\n  });\n  try {\n    const request = await fetch(`https://api.pinata.cloud/groups/${options.groupId}/cids`, {\n      method: \"DELETE\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing removeFromGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while removing CIDs from a group\");\n  }\n};\n\n// src/core/groups/deleteGroup.ts\nvar deleteGroup = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/deleteGroup\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/groups/${options.groupId}`, {\n      method: \"DELETE\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.text();\n    return res;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing deleteGroup: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while deleting a group\");\n  }\n};\n\n// src/core/signatures/addSignature.ts\nvar addSignature = async (config, options) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const data = JSON.stringify({\n    signature: options.signature\n  });\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/addSignature\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/v3/ipfs/signature/${options.cid}`, {\n      method: \"POST\",\n      headers,\n      body: data\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      if (request.status === 403) {\n        throw new PinataError(\"Unauthorized signing, you must be the original owner of the file and it must not have a signature\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.data;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing addSignature: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while adding signature to CID\");\n  }\n};\n\n// src/core/signatures/getSignature.ts\nvar getSignature = async (config, cid) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/getSignature\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/v3/ipfs/signature/${cid}`, {\n      method: \"GET\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    const res = await request.json();\n    return res.data;\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing getSignature: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while fetching signature for CID\");\n  }\n};\n\n// src/core/signatures/removeSignature.ts\nvar removeSignature = async (config, cid) => {\n  if (!config || !config.pinataJwt) {\n    throw new ValidationError(\"Pinata configuration or JWT is missing\");\n  }\n  const headers = {\n    \"Content-Type\": \"application/json\",\n    Authorization: `Bearer ${config?.pinataJwt}`\n  };\n  if (config.customHeaders) {\n    Object.assign(headers, config.customHeaders);\n  }\n  headers[\"Source\"] = headers[\"Source\"] || \"sdk/removeSignature\";\n  try {\n    const request = await fetch(`https://api.pinata.cloud/v3/ipfs/signature/${cid}`, {\n      method: \"DELETE\",\n      headers\n    });\n    if (!request.ok) {\n      const errorData = await request.json();\n      if (request.status === 401) {\n        throw new AuthenticationError(\"Authentication failed\", request.status, errorData);\n      }\n      throw new NetworkError(`HTTP error! status: ${request.status}`, request.status, errorData);\n    }\n    return \"OK\";\n  } catch (error) {\n    if (error instanceof PinataError) {\n      throw error;\n    }\n    if (error instanceof Error) {\n      throw new PinataError(`Error processing addSignature: ${error.message}`);\n    }\n    throw new PinataError(\"An unknown error occurred while adding signature to CID\");\n  }\n};\n\n// src/core/pinataSDK.ts\nvar formatConfig = config => {\n  let gateway = config?.pinataGateway;\n  if (config && gateway) {\n    if (gateway && !gateway.startsWith(\"https://\")) {\n      gateway = `https://${gateway}`;\n    }\n    config.pinataGateway = gateway;\n  }\n  return config;\n};\nvar PinataSDK = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n    this.upload = new Upload(this.config);\n    this.gateways = new Gateways(this.config);\n    this.usage = new Usage(this.config);\n    this.keys = new Keys(this.config);\n    this.groups = new Groups(this.config);\n    this.signatures = new Signatures(this.config);\n  }\n  testAuthentication() {\n    return testAuthentication(this.config);\n  }\n  unpin(files) {\n    return unpinFile(this.config, files);\n  }\n  listFiles() {\n    return new FilterFiles(this.config);\n  }\n  updateMetadata(options) {\n    return updateMetadata(this.config, options);\n  }\n  pinJobs() {\n    return new FilterPinJobs(this.config);\n  }\n};\nvar UploadBuilder = class {\n  constructor(config, uploadFunction, ...args) {\n    this.config = config;\n    this.uploadFunction = uploadFunction;\n    this.args = args;\n    this.version = 1;\n  }\n  addMetadata(metadata) {\n    this.metadata = metadata;\n    return this;\n  }\n  key(jwt) {\n    this.keys = jwt;\n    return this;\n  }\n  cidVersion(v) {\n    this.version = v;\n    return this;\n  }\n  group(groupId) {\n    this.groupId = groupId;\n    return this;\n  }\n  peerAddress(peerAddresses) {\n    this.peerAddresses = peerAddresses;\n    return this;\n  }\n  then(onfulfilled, onrejected) {\n    const options = this.args[this.args.length - 1] || {};\n    if (this.metadata) {\n      options.metadata = this.metadata;\n    }\n    if (this.keys) {\n      options.keys = this.keys;\n    }\n    if (this.groupId) {\n      options.groupId = this.groupId;\n    }\n    if (this.version) {\n      options.cidVersion = this.version;\n    }\n    if (this.peerAddresses && \"peerAddresses\" in options) {\n      options.peerAddresses = this.peerAddresses;\n    }\n    this.args[this.args.length - 1] = options;\n    return this.uploadFunction(this.config, ...this.args).then(onfulfilled, onrejected);\n  }\n};\nvar Upload = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  file(file, options) {\n    return new UploadBuilder(this.config, uploadFile, file, options);\n  }\n  fileArray(files, options) {\n    return new UploadBuilder(this.config, uploadFileArray, files, options);\n  }\n  base64(base64String, options) {\n    return new UploadBuilder(this.config, uploadBase64, base64String, options);\n  }\n  url(url, options) {\n    return new UploadBuilder(this.config, uploadUrl, url, options);\n  }\n  json(data, options) {\n    return new UploadBuilder(this.config, uploadJson, data, options);\n  }\n  cid(cid, options) {\n    return new UploadBuilder(this.config, uploadCid, cid, options);\n  }\n};\nvar FilterFiles = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  cid(cid) {\n    this.query.cid = cid;\n    return this;\n  }\n  pinStart(date) {\n    this.query.pinStart = date;\n    return this;\n  }\n  pinEnd(date) {\n    this.query.pinEnd = date;\n    return this;\n  }\n  pinSizeMin(size) {\n    this.query.pinSizeMin = size;\n    return this;\n  }\n  pinSizeMax(size) {\n    this.query.pinSizeMax = size;\n    return this;\n  }\n  pageLimit(limit) {\n    this.query.pageLimit = limit;\n    return this;\n  }\n  pageOffset(offset) {\n    this.query.pageOffset = offset;\n    return this;\n  }\n  name(name) {\n    this.query.name = name;\n    return this;\n  }\n  group(groupId) {\n    this.query.groupId = groupId;\n    return this;\n  }\n  keyValue(key, value, operator) {\n    this.query.key = key;\n    this.query.value = value;\n    if (operator) {\n      this.query.operator = operator;\n    }\n    return this;\n  }\n  then(onfulfilled) {\n    return listFiles(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise(resolve => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    const limit = this.query.pageLimit || 10;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.pageOffset = offset;\n      this.query.pageLimit = limit;\n      const items = await listFiles(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Gateways = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  get(cid) {\n    return getCid(this.config, cid);\n  }\n  convert(url) {\n    return convertIPFSUrl(this.config, url);\n  }\n};\nvar FilterPinJobs = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  cid(cid) {\n    this.query.ipfs_pin_hash = cid;\n    return this;\n  }\n  status(status) {\n    this.query.status = status;\n    return this;\n  }\n  pageLimit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  pageOffset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  sort(sort) {\n    this.query.sort = sort;\n    return this;\n  }\n  then(onfulfilled) {\n    return pinJobs(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise(resolve => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    const limit = this.query.limit || 10;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.offset = offset;\n      this.query.limit = limit;\n      const items = await pinJobs(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Usage = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  pinnedFileCount() {\n    return pinnedFileCount(this.config);\n  }\n  totalStorageSize() {\n    return totalStorageUsage(this.config);\n  }\n};\nvar Keys = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  create(options) {\n    return createKey(this.config, options);\n  }\n  list() {\n    return new FilterKeys(this.config);\n  }\n  revoke(keys) {\n    return revokeKeys(this.config, keys);\n  }\n};\nvar FilterKeys = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  revoked(revoked) {\n    this.query.revoked = revoked;\n    return this;\n  }\n  limitedUse(limitedUse) {\n    this.query.limitedUse = limitedUse;\n    return this;\n  }\n  exhausted(exhausted) {\n    this.query.exhausted = exhausted;\n    return this;\n  }\n  name(name) {\n    this.query.name = name;\n    return this;\n  }\n  then(onfulfilled) {\n    return listKeys(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise(resolve => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.offset = offset;\n      const items = await listKeys(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Groups = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  create(options) {\n    return createGroup(this.config, options);\n  }\n  list() {\n    return new FilterGroups(this.config);\n  }\n  get(options) {\n    return getGroup(this.config, options);\n  }\n  addCids(options) {\n    return addToGroup(this.config, options);\n  }\n  removeCids(options) {\n    return removeFromGroup(this.config, options);\n  }\n  update(options) {\n    return updateGroup(this.config, options);\n  }\n  delete(options) {\n    return deleteGroup(this.config, options);\n  }\n};\nvar FilterGroups = class {\n  constructor(config) {\n    this.query = {};\n    // rate limit vars\n    this.requestCount = 0;\n    this.lastRequestTime = 0;\n    this.MAX_REQUESTS_PER_MINUTE = 30;\n    this.MINUTE_IN_MS = 6e4;\n    this.config = config;\n  }\n  offset(offset) {\n    this.query.offset = offset;\n    return this;\n  }\n  name(nameContains) {\n    this.query.nameContains = nameContains;\n    return this;\n  }\n  limit(limit) {\n    this.query.limit = limit;\n    return this;\n  }\n  then(onfulfilled) {\n    return listGroups(this.config, this.query).then(onfulfilled);\n  }\n  // rate limit, hopefully temporary?\n  async rateLimit() {\n    this.requestCount++;\n    const now = Date.now();\n    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n      const timePassedSinceLastRequest = now - this.lastRequestTime;\n      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n        await new Promise(resolve => setTimeout(resolve, delayTime));\n      }\n      this.requestCount = 0;\n    }\n    this.lastRequestTime = Date.now();\n  }\n  async *[Symbol.asyncIterator]() {\n    let hasMore = true;\n    let offset = 0;\n    while (hasMore) {\n      await this.rateLimit();\n      this.query.offset = offset;\n      const items = await listGroups(this.config, this.query);\n      for (const item of items) {\n        yield item;\n      }\n      if (items.length === 0) {\n        hasMore = false;\n      } else {\n        offset += items.length;\n      }\n    }\n  }\n  async all() {\n    const allItems = [];\n    for await (const item of this) {\n      allItems.push(item);\n    }\n    return allItems;\n  }\n};\nvar Signatures = class {\n  constructor(config) {\n    this.config = formatConfig(config);\n  }\n  add(options) {\n    return addSignature(this.config, options);\n  }\n  get(cid) {\n    return getSignature(this.config, cid);\n  }\n  delete(cid) {\n    return removeSignature(this.config, cid);\n  }\n};\nexport { PinataSDK };","map":{"version":3,"names":["PinataError","Error","constructor","message","statusCode","details","name","NetworkError","AuthenticationError","ValidationError","testAuthentication","config","pinataJwt","headers","Authorization","customHeaders","Object","assign","request","fetch","method","ok","errorData","json","status","res","error","uploadFile","file","options","jwt","keys","data","FormData","append","JSON","stringify","cidVersion","groupId","metadata","keyvalues","keyValues","body","uploadFileArray","files","folder","Array","from","uploadBase64","base64String","buffer","Buffer","blob","Blob","uploadUrl","url","stream","arrayBuffer","File","uploadJson","jsonData","pinataContent","pinataOptions","pinataMetadata","uploadCid","cid","hashToPin","hostNodes","peerAddresses","wait","milliseconds","Promise","resolve","setTimeout","unpinFile","responses","hash","response","result","text","push","errorMessage","listFiles","params","URLSearchParams","includesCount","pinStart","pinEnd","pinSizeMin","pinSizeMax","pageLimit","pageOffset","key","value","operator","toString","keyValueParam","op","rows","updateMetadata","ipfsPinHash","isIPFSModule","getIsIPFS","containsCID","input","isIPFS","startsWithCID","str","parts","split","directCID","containsCid","URL","part","subdomains","hostname","subdomain","pathParts","pathname","convertToDesiredGateway","sourceUrl","desiredGatewayPrefix","results","startsWith","urlObj","path","search","includes","getCid","newUrl","pinataGateway","pinataGatewayKey","Source","contentType","get","convertIPFSUrl","pinJobs","ipfs_pin_hash","sort","limit","offset","pinnedFileCount","pin_count","totalStorageUsage","pin_size_total","createKey","listKeys","revoked","limitedUse","exhausted","wait2","revokeKeys","createGroup","listGroups","nameContains","getGroup","addToGroup","cids","updateGroup","removeFromGroup","deleteGroup","addSignature","signature","getSignature","removeSignature","formatConfig","gateway","PinataSDK","upload","Upload","gateways","Gateways","usage","Usage","Keys","groups","Groups","signatures","Signatures","unpin","FilterFiles","FilterPinJobs","UploadBuilder","uploadFunction","args","version","addMetadata","v","group","peerAddress","then","onfulfilled","onrejected","length","fileArray","base64","query","requestCount","lastRequestTime","MAX_REQUESTS_PER_MINUTE","MINUTE_IN_MS","date","size","keyValue","rateLimit","now","Date","timePassedSinceLastRequest","delayTime","Symbol","asyncIterator","hasMore","items","item","all","allItems","convert","totalStorageSize","create","list","FilterKeys","revoke","FilterGroups","addCids","removeCids","update","delete","add"],"sources":["/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/utils/custom-errors.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/authentication/testAuthentication.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/file.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/fileArray.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/base64.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/url.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/json.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/cid.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinning/unpin.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/data/listFiles.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/data/updateMetadata.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/utils/gateway-tools.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/gateway/getCid.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/gateway/convertIPFSUrl.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/data/pinJobs.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/data/pinnedFileUsage.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/data/totalStorageUsage.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/keys/createKey.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/keys/listKeys.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/keys/revokeKeys.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/createGroup.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/listGroups.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/getGroup.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/addToGroup.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/updateGroup.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/removeFromGroup.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/groups/deleteGroup.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/signatures/addSignature.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/signatures/getSignature.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/signatures/removeSignature.ts","/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/pinata/src/core/pinataSDK.ts"],"sourcesContent":["export class PinataError extends Error {\n\tconstructor(\n\t\tmessage: string,\n\t\tpublic statusCode?: number,\n\t\tpublic details?: any,\n\t) {\n\t\tsuper(message);\n\t\tthis.name = \"PinataError\";\n\t}\n}\n\nexport class NetworkError extends PinataError {\n\tconstructor(message: string, statusCode?: number, details?: any) {\n\t\tsuper(message, statusCode, details);\n\t\tthis.name = \"NetworkError\";\n\t}\n}\n\nexport class AuthenticationError extends PinataError {\n\tconstructor(message: string, statusCode?: number, details?: any) {\n\t\tsuper(message, statusCode, details);\n\t\tthis.name = \"AuthenticationError\";\n\t}\n}\n\nexport class ValidationError extends PinataError {\n\tconstructor(message: string, details?: any) {\n\t\tsuper(message, undefined, details);\n\t\tthis.name = \"ValidationError\";\n\t}\n}\n","/**\n * Tests the authentication of the current Pinata configuration.\n *\n * This function sends a request to the Pinata API to verify if the provided\n * authentication credentials (JWT) are valid and working correctly.\n *\n * @async\n * @function testAuthentication\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @returns {Promise<AuthTestResponse>} A promise that resolves to an object containing a message about the authentication status.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the authentication process.\n * @example\n *  import { PinataSDK } from \"pinata\";\n *\n *  const pinata = new PinataSDK({\n *    pinataJwt: process.env.PINATA_JWT!,\n *    pinataGateway: \"example-gateway.mypinata.cloud\",\n *  });\n *\n *  const auth = await pinata.testAuthentication()\n */\n\nimport type { PinataConfig, AuthTestResponse } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const testAuthentication = async (config: PinataConfig | undefined) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/testAuthentication\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/data/testAuthentication\",\n\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: headers,\n\t\t\t},\n\t\t);\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: AuthTestResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(\n\t\t\t\t`Error processing authentication: ${error.message}`,\n\t\t\t);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while testing authentication\",\n\t\t);\n\t}\n};\n","/**\n * Uploads a file to IPFS via Pinata.\n *\n * This function allows you to upload a single file to IPFS and pin it to Pinata.\n * It's useful for adding individual files to your Pinata account and IPFS network.\n *\n * @async\n * @function uploadFile\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {File} file - The file object to be uploaded.\n * @param {UploadOptions} [options] - Optional parameters for the upload.\n * @param {PinataMetadata} [options.metadata] - Metadata for the uploaded file.\n * @param {string} [options.metadata.name] - Custom name for the file (defaults to the original filename if not provided).\n * @param {Record<string, string | number>} [options.metadata.keyValues] - Custom key-value pairs for the file metadata.\n * @param {string} [options.keys] - Custom JWT to use for this specific upload.\n * @param {string} [options.groupId] - ID of the group to add the uploaded file to.\n * @param {0 | 1} [options.cidVersion] - Version of CID to use (0 or 1).\n * @returns {Promise<PinResponse>} A promise that resolves to an object containing the IPFS hash and other upload details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the upload process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const file = new File([\"hello world!\"], \"hello.txt\", { type: \"text/plain\" })\n * const upload = await pinata.upload.file(file)\n */\n\nimport type { PinataConfig, PinResponse, UploadOptions } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const uploadFile = async (\n\tconfig: PinataConfig | undefined,\n\tfile: File,\n\toptions?: UploadOptions,\n) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst jwt: string = options?.keys || config.pinataJwt;\n\n\tconst data = new FormData();\n\tdata.append(\"file\", file, file.name);\n\n\tdata.append(\n\t\t\"pinataOptions\",\n\t\tJSON.stringify({\n\t\t\tcidVersion: options?.cidVersion,\n\t\t\tgroupId: options?.groupId,\n\t\t}),\n\t);\n\n\tdata.append(\n\t\t\"pinataMetadata\",\n\t\tJSON.stringify({\n\t\t\tname: options?.metadata ? options.metadata.name : file.name,\n\t\t\tkeyvalues: options?.metadata?.keyValues,\n\t\t}),\n\t);\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${jwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/file\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\t\tconst res: PinResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error uploading file: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while uploading the file\");\n\t}\n};\n","/**\n * Uploads multiple files to IPFS via Pinata as a single directory.\n *\n * This function allows you to upload multiple files to IPFS and pin them to Pinata\n * as a single directory. It's useful for adding collections of related files or\n * entire directories to your Pinata account and IPFS network.\n *\n * @async\n * @function uploadFileArray\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {File[]} files - An array of File objects to be uploaded.\n * @param {UploadOptions} [options] - Optional parameters for the upload.\n * @param {PinataMetadata} [options.metadata] - Metadata for the uploaded directory.\n * @param {string} [options.metadata.name] - Name for the directory (defaults to \"folder_from_sdk\" if not provided).\n * @param {Record<string, string | number>} [options.metadata.keyValues] - Custom key-value pairs for the directory metadata.\n * @param {string} [options.keys] - Custom JWT to use for this specific upload.\n * @param {string} [options.groupId] - ID of the group to add the uploaded directory to.\n * @param {0 | 1} [options.cidVersion] - Version of CID to use (0 or 1).\n * @returns {Promise<PinResponse>} A promise that resolves to an object containing the IPFS hash and other upload details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the upload process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const file1 = new File([\"hello world!\"], \"hello.txt\", { type: \"text/plain\" })\n * const file2 = new File([\"hello world again!\"], \"hello2.txt\", { type: \"text/plain\" })\n * const upload = await pinata.upload.fileArray([file1, file2])\n */\n\nimport type { PinataConfig, PinResponse, UploadOptions } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const uploadFileArray = async (\n\tconfig: PinataConfig | undefined,\n\tfiles: File[],\n\toptions?: UploadOptions,\n) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst jwt: string = options?.keys || config?.pinataJwt;\n\n\tconst folder = options?.metadata?.name ?? \"folder_from_sdk\";\n\tconst data = new FormData();\n\n\tfor (const file of Array.from(files)) {\n\t\tdata.append(\"file\", file, `${folder}/${file.name}`);\n\t}\n\n\tdata.append(\n\t\t\"pinataMetadata\",\n\t\tJSON.stringify({\n\t\t\tname: folder,\n\t\t\tkeyvalues: options?.metadata?.keyValues,\n\t\t}),\n\t);\n\n\tdata.append(\n\t\t\"pinataOptions\",\n\t\tJSON.stringify({\n\t\t\tcidVersion: options?.cidVersion,\n\t\t\tgroupId: options?.groupId,\n\t\t}),\n\t);\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${jwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/fileArray\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: PinResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing fileArray: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while uploading an array of files\",\n\t\t);\n\t}\n};\n","/**\n * Uploads a base64-encoded string to IPFS via Pinata.\n *\n * This function allows you to upload content to IPFS that is encoded as a base64 string.\n * It's particularly useful for uploading binary data or files that have been converted to base64.\n *\n * @async\n * @function uploadBase64\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string} base64String - The base64-encoded string to be uploaded.\n * @param {UploadOptions} [options] - Optional parameters for the upload.\n * @param {PinataMetadata} [options.metadata] - Metadata for the uploaded file.\n * @param {string} [options.metadata.name] - Name for the uploaded file (default is \"base64 string\").\n * @param {Record<string, string | number>} [options.metadata.keyvalues] - Custom key-value pairs for the file metadata.\n * @param {string} [options.keys] - Custom JWT to use for this specific upload.\n * @param {string} [options.groupId] - ID of the group to add the uploaded file to.\n * @param {0 | 1} [options.cidVersion] - Version of CID to use (0 or 1).\n * @returns {Promise<PinResponse>} A promise that resolves to an object containing the IPFS hash and other upload details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the upload process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const upload = await pinata.upload.base64(\"SGVsbG8gV29ybGQh\")\n */\n\nimport type { PinataConfig, PinResponse, UploadOptions } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const uploadBase64 = async (\n\tconfig: PinataConfig | undefined,\n\tbase64String: string,\n\toptions?: UploadOptions,\n) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst jwt: string = options?.keys || config?.pinataJwt;\n\n\tconst name = options?.metadata?.name\n\t\t? options?.metadata?.name\n\t\t: \"base64 string\";\n\n\tconst buffer = Buffer.from(base64String, \"base64\");\n\n\tconst blob = new Blob([buffer]);\n\n\tconst data = new FormData();\n\n\tdata.append(\"file\", blob, name);\n\n\tdata.append(\n\t\t\"pinataOptions\",\n\t\tJSON.stringify({\n\t\t\tcidVersion: options?.cidVersion,\n\t\t\tgroupId: options?.groupId,\n\t\t}),\n\t);\n\n\tdata.append(\n\t\t\"pinataMetadata\",\n\t\tJSON.stringify({\n\t\t\tname: name,\n\t\t\tkeyvalues: options?.metadata?.keyValues,\n\t\t}),\n\t);\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${jwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/base64\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: PinResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing base64: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while trying to upload base64\",\n\t\t);\n\t}\n};\n","/**\n * Uploads content from a URL to IPFS via Pinata.\n *\n * This function allows you to upload content from a specified URL to IPFS and pin it to Pinata.\n * It's useful for adding remote content to your Pinata account and IPFS network without\n * first downloading it locally.\n *\n * @async\n * @function uploadUrl\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string} url - The URL of the content to be uploaded.\n * @param {UploadOptions} [options] - Optional parameters for the upload.\n * @param {PinataMetadata} [options.metadata] - Metadata for the uploaded content.\n * @param {string} [options.metadata.name] - Custom name for the content (defaults to \"url_upload\" if not provided).\n * @param {Record<string, string | number>} [options.metadata.keyValues] - Custom key-value pairs for the content metadata.\n * @param {string} [options.keys] - Custom JWT to use for this specific upload.\n * @param {string} [options.groupId] - ID of the group to add the uploaded content to.\n * @param {0 | 1} [options.cidVersion] - Version of CID to use (0 or 1).\n * @returns {Promise<PinResponse>} A promise that resolves to an object containing the IPFS hash and other upload details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request or URL fetch.\n * @throws {PinataError} For any other errors that occur during the upload process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const upload = await pinata.upload.url(\"https://i.imgur.com/u4mGk5b.gif\")\n */\n\nimport type { PinataConfig, PinResponse, UploadOptions } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const uploadUrl = async (\n\tconfig: PinataConfig | undefined,\n\turl: string,\n\toptions?: UploadOptions,\n) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst jwt: string = options?.keys || config?.pinataJwt;\n\tconst data = new FormData();\n\n\tconst stream = await fetch(url);\n\n\tif (!stream.ok) {\n\t\tconst errorData = await stream.json();\n\t\tthrow new NetworkError(\n\t\t\t`HTTP error! status: ${stream.status}`,\n\t\t\tstream.status,\n\t\t\terrorData,\n\t\t);\n\t}\n\n\tconst arrayBuffer = await stream.arrayBuffer();\n\n\tconst blob = new Blob([arrayBuffer]);\n\n\tconst name = options?.metadata?.name ?? \"url_upload\";\n\n\tconst file = new File([blob], name);\n\n\tdata.append(\"file\", file, name);\n\n\tdata.append(\n\t\t\"pinataOptions\",\n\t\tJSON.stringify({\n\t\t\tcidVersion: options?.cidVersion,\n\t\t\tgroupId: options?.groupId,\n\t\t}),\n\t);\n\n\tdata.append(\n\t\t\"pinataMetadata\",\n\t\tJSON.stringify({\n\t\t\tname: name,\n\t\t\tkeyvalues: options?.metadata?.keyValues,\n\t\t}),\n\t);\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${jwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/url\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/pinning/pinFileToIPFS\",\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: PinResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing url: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while uploading by url\");\n\t}\n};\n","/**\n * Uploads JSON data to IPFS via Pinata.\n *\n * This function allows you to upload JSON data directly to IPFS and pin it to Pinata.\n * It's useful for adding structured data, configurations, or any JSON-serializable content\n * to your Pinata account and IPFS network.\n *\n * @async\n * @function uploadJson\n * @template T\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {T} jsonData - The JSON data to be uploaded. Must be a valid JavaScript object that can be JSON-stringified.\n * @param {UploadOptions} [options] - Optional parameters for the upload.\n * @param {PinataMetadata} [options.metadata] - Metadata for the uploaded JSON.\n * @param {string} [options.metadata.name] - Custom name for the JSON content (defaults to \"json\" if not provided).\n * @param {Record<string, string | number>} [options.metadata.keyValues] - Custom key-value pairs for the JSON metadata.\n * @param {string} [options.keys] - Custom JWT to use for this specific upload.\n * @param {string} [options.groupId] - ID of the group to add the uploaded JSON to.\n * @param {0 | 1} [options.cidVersion] - Version of CID to use (0 or 1).\n * @returns {Promise<PinResponse>} A promise that resolves to an object containing the IPFS hash and other upload details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the upload process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const upload = await pinata.upload.json({\n *   name: \"Pinnie NFT\",\n *   description: \"A Pinnie NFT from Pinata\",\n *   image: \"ipfs://bafkreih5aznjvttude6c3wbvqeebb6rlx5wkbzyppv7garjiubll2ceym4\"\n * })\n */\n\nimport type {\n\tPinataConfig,\n\tPinResponse,\n\tUploadOptions,\n\tJsonBody,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const uploadJson = async <T extends JsonBody>(\n\tconfig: PinataConfig | undefined,\n\tjsonData: T,\n\toptions?: UploadOptions,\n) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst jwt: string = options?.keys || config?.pinataJwt;\n\n\tconst data = JSON.stringify({\n\t\tpinataContent: jsonData,\n\t\tpinataOptions: {\n\t\t\tcidVersion: options?.cidVersion,\n\t\t\tgroupId: options?.groupId,\n\t\t},\n\t\tpinataMetadata: {\n\t\t\tname: options?.metadata ? options.metadata.name : \"json\",\n\t\t\tkeyvalues: options?.metadata?.keyValues,\n\t\t},\n\t});\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${jwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/json\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/pinning/pinJSONToIPFS\",\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: PinResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing json: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while uploading json\");\n\t}\n};\n","/**\n * Pins an existing file on IPFS to Pinata using its Content Identifier (CID).\n *\n * This function allows you to add an existing IPFS file to your Pinata account\n * by providing its CID. It's useful for ensuring long-term storage and\n * availability of content that's already on IPFS.\n *\n * @async\n * @function uploadCid\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string} cid - The Content Identifier (CID) of the IPFS file to pin.\n * @param {UploadCIDOptions} [options] - Optional parameters for the upload.\n * @param {PinataMetadata} [options.metadata] - Metadata for the pinned file.\n * @param {string} [options.metadata.name] - Name for the pinned file (defaults to the CID if not provided).\n * @param {Record<string, string | number>} [options.metadata.keyValues] - Custom key-value pairs for the file metadata.\n * @param {string[]} [options.peerAddresses] - Array of peer addresses to contact for pinning.\n * @param {string} [options.keys] - Custom JWT to use for this specific upload.\n * @param {string} [options.groupId] - ID of the group to add the pinned file to.\n * @returns {Promise<PinByCIDResponse>} A promise that resolves to an object containing details about the pinning job.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the pinning process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const pin = await pinata.upload.cid(\"QmVLwvmGehsrNEvhcCnnsw5RQNseohgEkFNN1848zNzdng\")\n */\n\nimport type {\n\tPinataConfig,\n\tPinByCIDResponse,\n\tUploadCIDOptions,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const uploadCid = async (\n\tconfig: PinataConfig | undefined,\n\tcid: string,\n\toptions?: UploadCIDOptions,\n) => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst jwt: string = options?.keys || config?.pinataJwt;\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${jwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/cid\";\n\n\tconst data = JSON.stringify({\n\t\thashToPin: cid,\n\t\tpinataMetadata: {\n\t\t\tname: options?.metadata ? options?.metadata?.name : cid,\n\t\t\tkeyvalues: options?.metadata?.keyValues,\n\t\t},\n\t\tpinataOptions: {\n\t\t\thostNodes: options?.peerAddresses ? options.peerAddresses : \"\",\n\t\t\tgroupId: options?.groupId,\n\t\t},\n\t});\n\n\ttry {\n\t\tconst request = await fetch(\"https://api.pinata.cloud/pinning/pinByHash\", {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: headers,\n\t\t\tbody: data,\n\t\t});\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: PinByCIDResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing cid: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while pinning by CID\");\n\t}\n};\n","/**\n * Unpins multiple files from Pinata and IPFS.\n *\n * This function allows you to remove pins for multiple files from your Pinata account.\n * Unpinning a file means that Pinata will no longer guarantee its availability on IPFS,\n * although the content may still be available if pinned by other IPFS nodes.\n *\n * @async\n * @function unpinFile\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string[]} files - An array of IPFS hashes (CIDs) of the files to unpin.\n * @returns {Promise<UnpinResponse[]>} A promise that resolves to an array of objects, each containing the status of the unpin operation for each file.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the unpinning process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const unpin = await pinata.unpin([\n *   \"bafkreih5aznjvttude6c3wbvqeebb6rlx5wkbzyppv7garjiubll2ceym4\"\n * ])\n */\n\nimport type { PinataConfig, UnpinResponse } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nconst wait = (milliseconds: number): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\tsetTimeout(resolve, milliseconds);\n\t});\n};\n\nexport const unpinFile = async (\n\tconfig: PinataConfig | undefined,\n\tfiles: string[],\n): Promise<UnpinResponse[]> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst responses: UnpinResponse[] = [];\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/unpin\";\n\n\tfor (const hash of files) {\n\t\ttry {\n\t\t\tconst response = await fetch(\n\t\t\t\t`https://api.pinata.cloud/pinning/unpin/${hash}`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"DELETE\",\n\t\t\t\t\theaders: headers,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tawait wait(300);\n\n\t\t\tif (!response.ok) {\n\t\t\t\tconst errorData = await response.json();\n\t\t\t\tif (response.status === 401) {\n\t\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\t\tresponse.status,\n\t\t\t\t\t\terrorData,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthrow new NetworkError(\n\t\t\t\t\t`HTTP error! status: ${response.status}`,\n\t\t\t\t\tresponse.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst result = await response.text();\n\t\t\tresponses.push({\n\t\t\t\thash: hash,\n\t\t\t\tstatus: result,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlet errorMessage: string;\n\n\t\t\tif (error instanceof PinataError) {\n\t\t\t\terrorMessage = error.message;\n\t\t\t} else if (error instanceof Error) {\n\t\t\t\terrorMessage = `Error unpinning file ${hash}: ${error.message}`;\n\t\t\t} else {\n\t\t\t\terrorMessage = `An unknown error occurred while unpinning file ${hash}`;\n\t\t\t}\n\n\t\t\tresponses.push({\n\t\t\t\thash: hash,\n\t\t\t\tstatus: errorMessage,\n\t\t\t});\n\t\t}\n\t}\n\treturn responses;\n};\n","/**\n * Lists files pinned to Pinata based on the provided configuration and options.\n *\n * This function fetches a list of pinned files from the Pinata API, allowing for\n * various filtering and pagination options.\n *\n * @async\n * @function listFiles\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {PinListQuery} [options] - Optional query parameters to filter and paginate the results.\n * @param {string} [options.cid] - Filter by the CID of the file.\n * @param {string} [options.pinStart] - Filter by the start date of pinning (ISO 8601 format).\n * @param {string} [options.pinEnd] - Filter by the end date of pinning (ISO 8601 format).\n * @param {number} [options.pinSizeMin] - Filter by minimum pin size in bytes.\n * @param {number} [options.pinSizeMax] - Filter by maximum pin size in bytes.\n * @param {number} [options.pageLimit] - Number of items to return per page.\n * @param {number} [options.pageOffset] - Number of items to skip (for pagination).\n * @param {string} [options.name] - Filter by the name of the file.\n * @param {string} [options.key] - Metadata key to filter by (used with value and operator).\n * @param {string | number} [options.value] - Metadata value to filter by (used with key and operator).\n * @param {string} [options.operator] - Comparison operator for metadata filtering.\n * @param {string} [options.groupId] - Filter by group ID.\n * @returns {Promise<PinListItem[]>} A promise that resolves to an array of PinListItem objects.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the file listing process.\n *//**\n * Lists files pinned to Pinata based on the provided configuration and options.\n *\n * This function fetches a list of pinned files from the Pinata API, allowing for\n * various filtering and pagination options.\n *\n * @async\n * @function listFiles\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {PinListQuery} [options] - Optional query parameters to filter and paginate the results.\n * @param {string} [options.cid] - Filter by the CID of the file.\n * @param {string} [options.pinStart] - Filter by the start date of pinning (ISO 8601 format).\n * @param {string} [options.pinEnd] - Filter by the end date of pinning (ISO 8601 format).\n * @param {number} [options.pinSizeMin] - Filter by minimum pin size in bytes.\n * @param {number} [options.pinSizeMax] - Filter by maximum pin size in bytes.\n * @param {number} [options.pageLimit] - Number of items to return per page.\n * @param {number} [options.pageOffset] - Number of items to skip (for pagination).\n * @param {string} [options.name] - Filter by the name of the file.\n * @param {string} [options.key] - Metadata key to filter by (used with value and operator).\n * @param {string | number} [options.value] - Metadata value to filter by (used with key and operator).\n * @param {string} [options.operator] - Comparison operator for metadata filtering.\n * @param {string} [options.groupId] - Filter by group ID.\n * @returns {Promise<PinListItem[]>} A promise that resolves to an array of PinListItem objects.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the file listing process.\n * @example\n *  import { PinataSDK } from \"pinata\";\n *\n *  const pinata = new PinataSDK({\n *    pinataJwt: process.env.PINATA_JWT!,\n *    pinataGateway: \"example-gateway.mypinata.cloud\",\n *  });\n *\n *  const files = await pinata.listFiles().name(\"pinnie\")\n */\n\nimport type {\n\tPinListItem,\n\tPinListQuery,\n\tPinListResponse,\n\tPinataConfig,\n} from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const listFiles = async (\n\tconfig: PinataConfig | undefined,\n\toptions?: PinListQuery,\n): Promise<PinListItem[]> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst params = new URLSearchParams({\n\t\tincludesCount: \"false\",\n\t});\n\n\tif (options) {\n\t\tconst {\n\t\t\tcid,\n\t\t\tpinStart,\n\t\t\tpinEnd,\n\t\t\tpinSizeMin,\n\t\t\tpinSizeMax,\n\t\t\tpageLimit,\n\t\t\tpageOffset,\n\t\t\tname,\n\t\t\tkey,\n\t\t\tvalue,\n\t\t\toperator,\n\t\t\tgroupId,\n\t\t} = options;\n\n\t\tif (cid) params.append(\"cid\", cid);\n\t\tif (pinStart) params.append(\"pinStart\", pinStart);\n\t\tif (pinEnd) params.append(\"pinEnd\", pinEnd);\n\t\tif (pinSizeMin) params.append(\"pinSizeMin\", pinSizeMin.toString());\n\t\tif (pinSizeMax) params.append(\"pinSizeMax\", pinSizeMax.toString());\n\t\tif (pageLimit) params.append(\"pageLimit\", pageLimit.toString());\n\t\tif (pageOffset) params.append(\"pageOffset\", pageOffset.toString());\n\t\tif (groupId) params.append(\"groupId\", groupId);\n\t\tif (name) params.append(\"metadata[name]\", name);\n\t\tif (key && value) {\n\t\t\tconst keyValueParam = JSON.stringify({\n\t\t\t\t[key]: { value, op: operator || \"eq\" },\n\t\t\t});\n\t\t\tparams.append(\"metadata[keyvalues]\", keyValueParam);\n\t\t}\n\t}\n\n\tconst url = `https://api.pinata.cloud/data/pinList?status=pinned&${params.toString()}`;\n\n\ttry {\n\t\tconst headers: Record<string, string> = {\n\t\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t\t};\n\n\t\tif (config.customHeaders) {\n\t\t\tObject.assign(headers, config.customHeaders);\n\t\t}\n\n\t\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\t\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/listFiles\";\n\n\t\tconst request = await fetch(url, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: headers,\n\t\t});\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: PinListResponse = await request.json();\n\t\treturn res.rows;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing list files: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while listing files\");\n\t}\n};\n","/**\n * Updates the metadata for a pinned file on Pinata.\n *\n * This function allows you to modify the name and/or key-value pairs associated\n * with a file that has already been pinned to Pinata. This is useful for\n * organizing and categorizing your pinned content.\n *\n * @async\n * @function updateMetadata\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {PinataMetadataUpdate} options - The options for updating the metadata.\n * @param {string} options.cid - The Content Identifier (CID) of the pinned file to update.\n * @param {string} [options.name] - The new name to assign to the pinned file (optional).\n * @param {Record<string, string | number>} [options.keyValues] - Key-value pairs to associate with the pinned file (optional).\n * @returns {Promise<string>} A promise that resolves to a string confirming the update.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the metadata update process.\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const update = await pinata.updateMedatadata({\n *   cid: \"bafkreih5aznjvttude6c3wbvqeebb6rlx5wkbzyppv7garjiubll2ceym4\",\n *   name: \"Pinnie V2\",\n *   keyValues: {\n *     whimsey: 200\n *   }\n * })\n */\n\nimport type { PinataConfig, PinataMetadataUpdate } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const updateMetadata = async (\n\tconfig: PinataConfig | undefined,\n\toptions: PinataMetadataUpdate,\n): Promise<string> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\tconst data = {\n\t\tipfsPinHash: options.cid,\n\t\tname: options.name,\n\t\tkeyvalues: options.keyValues,\n\t};\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/updateMetadata\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t\"https://api.pinata.cloud/pinning/hashMetadata\",\n\t\t\t{\n\t\t\t\tmethod: \"PUT\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: JSON.stringify(data),\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: string = await request.text();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(\n\t\t\t\t`Error processing updateMetadata: ${error.message}`,\n\t\t\t);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while updating metadata\");\n\t}\n};\n","import type * as IsIPFS from \"is-ipfs\";\n\nlet isIPFSModule: typeof IsIPFS;\n\nasync function getIsIPFS() {\n\tif (!isIPFSModule) {\n\t\tisIPFSModule = await import(\"is-ipfs\");\n\t}\n\treturn isIPFSModule;\n}\n\nasync function containsCID(input: string) {\n\tif (typeof input !== \"string\") {\n\t\tthrow new Error(\"Input is not a string\");\n\t}\n\n\tconst isIPFS = await getIsIPFS();\n\n\t// Helper function to check if a string starts with a CID\n\tconst startsWithCID = (str: string) => {\n\t\tconst parts = str.split(\"/\");\n\t\treturn isIPFS.cid(parts[0]) ? parts[0] : null;\n\t};\n\n\t// Check if the input itself is a CID or starts with a CID\n\tconst directCID = startsWithCID(input);\n\tif (directCID) {\n\t\treturn {\n\t\t\tcontainsCid: true,\n\t\t\tcid: directCID,\n\t\t};\n\t}\n\n\tlet url: URL;\n\ttry {\n\t\t// Try to parse the input as a URL\n\t\turl = new URL(input);\n\t} catch (error) {\n\t\t// If parsing fails, treat the input as a potential path-like string\n\t\tconst parts = input.split(/\\/|\\?/);\n\t\tfor (const part of parts) {\n\t\t\tconst cid = startsWithCID(part);\n\t\t\tif (cid) {\n\t\t\t\treturn {\n\t\t\t\t\tcontainsCid: true,\n\t\t\t\t\tcid: cid,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tcontainsCid: false,\n\t\t\tcid: null,\n\t\t};\n\t}\n\n\t// Check for CID in subdomain\n\tconst subdomains = url.hostname.split(\".\");\n\tfor (const subdomain of subdomains) {\n\t\tif (isIPFS.cid(subdomain)) {\n\t\t\treturn {\n\t\t\t\tcontainsCid: true,\n\t\t\t\tcid: subdomain,\n\t\t\t};\n\t\t}\n\t}\n\n\t// Check for CID in path\n\tconst pathParts = url.pathname.split(\"/\");\n\tfor (const part of pathParts) {\n\t\tconst cid = startsWithCID(part);\n\t\tif (cid) {\n\t\t\treturn {\n\t\t\t\tcontainsCid: true,\n\t\t\t\tcid: cid,\n\t\t\t};\n\t\t}\n\t}\n\n\treturn {\n\t\tcontainsCid: false,\n\t\tcid: null,\n\t};\n}\n\nexport async function convertToDesiredGateway(\n\tsourceUrl: string,\n\tdesiredGatewayPrefix: string | undefined,\n) {\n\tconst results = await containsCID(sourceUrl);\n\n\tif (results.containsCid !== true) {\n\t\tthrow new Error(\"url does not contain CID\");\n\t}\n\n\tif (!sourceUrl.startsWith(\"https\") && !sourceUrl.startsWith(\"ipfs://\")) {\n\t\treturn `${desiredGatewayPrefix}/ipfs/${sourceUrl}`;\n\t}\n\n\tconst urlObj = new URL(sourceUrl);\n\tconst path = urlObj.pathname + urlObj.search + urlObj.hash;\n\n\t//case 1 - the ipfs://cid path\n\tif (sourceUrl.startsWith(`ipfs://${results.cid}`)) {\n\t\treturn `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;\n\t}\n\n\t//case 2 - the /ipfs/cid path (this should cover ipfs://ipfs/cid as well)\n\tif (sourceUrl.includes(`/ipfs/${results.cid}`)) {\n\t\treturn `${desiredGatewayPrefix}${path}`;\n\t}\n\n\t//case 3 - the /ipns/cid path\n\tif (sourceUrl.includes(`/ipns/${results.cid}`)) {\n\t\treturn `${desiredGatewayPrefix}${path}`;\n\t}\n\n\t//case 4 - the CID is in the subdomain\n\tif (urlObj.hostname.includes(results.cid!)) {\n\t\treturn `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;\n\t}\n\n\t//this is the fallback if no supported patterns are provided\n\tthrow new Error(\n\t\t\"unsupported URL pattern, please submit a github issue with the URL utilized\",\n\t);\n}\n","/**\n * Retrieves the content of a file from IPFS using its Content Identifier (CID).\n *\n * This function fetches the content associated with a given CID from the specified\n * Pinata gateway. It can handle various content types and returns the data along\n * with the content type information.\n *\n * @async\n * @function getCid\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT and gateway information.\n * @param {string} cid - The Content Identifier (CID) of the file to retrieve.\n * @returns {Promise<GetCIDResponse>} A promise that resolves to an object containing the file data and content type.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the retrieval process.\n *\n * @example\n *  import { PinataSDK } from \"pinata\";\n *\n *  const pinata = new PinataSDK({\n *    pinataJwt: process.env.PINATA_JWT!,\n *    pinataGateway: \"example-gateway.mypinata.cloud\",\n *  });\n *\n *  const upload = await pinata.gateways.get(\"QmVLwvmGehsrNEvhcCnnsw5RQNseohgEkFNN1848zNzdng\"* )\n *\n */\n\nimport { convertToDesiredGateway } from \"../../utils/gateway-tools\";\nimport type { GetCIDResponse, PinataConfig } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const getCid = async (\n\tconfig: PinataConfig | undefined,\n\tcid: string,\n): Promise<GetCIDResponse> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tlet data: JSON | string | Blob;\n\tlet newUrl: string;\n\n\tnewUrl = await convertToDesiredGateway(cid, config?.pinataGateway);\n\n\tif (config?.pinataGatewayKey) {\n\t\tnewUrl = `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;\n\t}\n\n\ttry {\n\t\tconst request = await fetch(newUrl, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: {\n\t\t\t\tSource: \"sdk/getCid\",\n\t\t\t},\n\t\t});\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst contentType: string | null = request.headers.get(\"content-type\");\n\n\t\tif (contentType?.includes(\"application/json\")) {\n\t\t\tdata = await request.json();\n\t\t} else if (contentType?.includes(\"text/\")) {\n\t\t\tdata = await request.text();\n\t\t} else {\n\t\t\tdata = await request.blob();\n\t\t}\n\n\t\tconst res: GetCIDResponse = {\n\t\t\tdata: data,\n\t\t\tcontentType: contentType,\n\t\t};\n\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing getCid: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while getting CID contents\",\n\t\t);\n\t}\n};\n","/**\n * Converts an IPFS URL to a desired gateway URL.\n *\n * This function takes an IPFS URL and converts it to use a specified gateway.\n * If a Pinata Gateway Key is provided in the configuration, it will be appended\n * to the URL as a query parameter.\n *\n * @function convertIPFSUrl\n * @param {PinataConfig | undefined} config - The Pinata configuration object.\n * @param {string} config.pinataGateway - The desired gateway URL to use.\n * @param {string} [config.pinataGatewayKey] - Optional Pinata Gateway Key for authenticated access.\n * @param {string} url - The original IPFS URL to convert.\n * @returns {Promise<string>} The converted URL using the specified gateway.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const url = await pinata.gateways.convert(\n *   \"ipfs://QmVLwvmGehsrNEvhcCnnsw5RQNseohgEkFNN1848zNzdng\"\n * );\n */\n\nimport { convertToDesiredGateway } from \"../../utils/gateway-tools\";\nimport type { PinataConfig } from \"../types\";\n\nexport const convertIPFSUrl = async (\n\tconfig: PinataConfig | undefined,\n\turl: string,\n): Promise<string> => {\n\tlet newUrl: string;\n\tnewUrl = await convertToDesiredGateway(url, config?.pinataGateway);\n\tif (config?.pinataGatewayKey) {\n\t\t`${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;\n\t}\n\treturn newUrl;\n};\n","/**\n * Retrieves information about pin jobs from the Pinata API.\n *\n * This function fetches a list of pin jobs based on the provided configuration and options.\n * Pin jobs represent the status of pinning operations in progress or completed.\n *\n * @async\n * @function pinJobs\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {PinJobQuery} [options] - Optional query parameters to filter and paginate the results.\n * @param {string} [options.ipfs_pin_hash] - Filter by the IPFS hash (CID) of the content being pinned.\n * @param {('prechecking'|'retrieving'|'expired'|'over_free_limit'|'over_max_size'|'invalid_object'|'bad_host_node')} [options.status] - Filter by the status of the pin job.\n * @param {('ASC'|'DSC')} [options.sort] - Sort order for the results (ascending or descending).\n * @param {number} [options.limit] - Number of items to return per page.\n * @param {number} [options.offset] - Number of items to skip (for pagination).\n * @returns {Promise<PinJobItem[]>} A promise that resolves to an array of PinJobItem objects.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the pin jobs retrieval process.\n *  @example\n *  import { PinataSDK } from \"pinata\";\n *\n *  const pinata = new PinataSDK({\n *    pinataJwt: process.env.PINATA_JWT!,\n *    pinataGateway: \"example-gateway.mypinata.cloud\",\n *  });\n *  const jobs = await pinata.pinJobs().status(\"prechecking\")\n */\n\nimport type {\n\tPinJobItem,\n\tPinJobQuery,\n\tPinJobResponse,\n\tPinataConfig,\n} from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const pinJobs = async (\n\tconfig: PinataConfig | undefined,\n\toptions?: PinJobQuery,\n): Promise<PinJobItem[]> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst params = new URLSearchParams({\n\t\tincludesCount: \"false\",\n\t});\n\n\tif (options) {\n\t\tconst { ipfs_pin_hash: cid, status, sort, limit, offset } = options;\n\n\t\tif (cid) params.append(\"ipfs_pin_hash\", cid.toString());\n\t\tif (status) params.append(\"status\", status.toString());\n\t\tif (sort) params.append(\"sort\", sort.toString());\n\t\tif (limit) params.append(\"limit\", limit.toString());\n\t\tif (offset) params.append(\"offset\", offset.toString());\n\t}\n\n\tconst url = `https://api.pinata.cloud/pinning/pinJobs?${params.toString()}`;\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/pinJobs\";\n\n\ttry {\n\t\tconst request = await fetch(url, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: headers,\n\t\t});\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\t\tconst res: PinJobResponse = await request.json();\n\t\treturn res.rows;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing pinJobs: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while listing pin jobs\");\n\t}\n};\n","/**\n * Retrieves the total count of files pinned to Pinata for the authenticated user.\n *\n * This function makes a request to the Pinata API to fetch the total number of files\n * that the user has pinned to their account. This can be useful for monitoring\n * account usage and managing pinned content.\n *\n * @async\n * @function pinnedFileCount\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @returns {Promise<number>} A promise that resolves to the total number of pinned files.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the retrieval process.\n *\n * @example\n * const config = { pinataJwt: 'your-jwt-token' };\n * try {\n *   const count = await pinnedFileCount(config);\n *   console.log(`Total pinned files: ${count}`);\n * } catch (error) {\n *   console.error('Error getting pinned file count:', error);\n * }\n */\n\nimport type { PinataConfig, UserPinnedDataResponse } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const pinnedFileCount = async (\n\tconfig: PinataConfig | undefined,\n): Promise<number> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst url = \"https://api.pinata.cloud/data/userPinnedDataTotal\";\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/pinnedFileUsage\";\n\n\ttry {\n\t\tconst request = await fetch(url, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: headers,\n\t\t});\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\t\tconst res: UserPinnedDataResponse = await request.json();\n\t\treturn res.pin_count;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(\n\t\t\t\t`Error processing pinnedFileUsage: ${error.message}`,\n\t\t\t);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while getting pinned file usage\",\n\t\t);\n\t}\n};\n","/**\n * Retrieves the total storage usage in bytes for all files pinned to Pinata by the authenticated user.\n *\n * This function makes a request to the Pinata API to fetch the total storage size\n * of all files that the user has pinned to their account. This can be useful for\n * monitoring account usage, managing storage limits, and planning for capacity.\n *\n * @async\n * @function totalStorageUsage\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @returns {Promise<number>} A promise that resolves to the total storage usage in bytes.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the retrieval process.\n *\n * @example\n * const config = { pinataJwt: 'your-jwt-token' };\n * try {\n *   const totalBytes = await totalStorageUsage(config);\n *   console.log(`Total storage usage: ${totalBytes} bytes`);\n *   console.log(`Total storage usage: ${totalBytes / (1024 * 1024)} MB`);\n * } catch (error) {\n *   console.error('Error getting total storage usage:', error);\n * }\n */\n\nimport type { PinataConfig, UserPinnedDataResponse } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const totalStorageUsage = async (\n\tconfig: PinataConfig | undefined,\n): Promise<number> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst url = \"https://api.pinata.cloud/data/userPinnedDataTotal\";\n\n\tconst headers: Record<string, string> = {\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/totalStorageUsage\";\n\n\ttry {\n\t\tconst request = await fetch(url, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: headers,\n\t\t});\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\t\tconst res: UserPinnedDataResponse = await request.json();\n\t\treturn res.pin_size_total;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(\n\t\t\t\t`Error processing totalStorageUsage: ${error.message}`,\n\t\t\t);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while getting total storage usage\",\n\t\t);\n\t}\n};\n","/**\n * Creates a new API key for Pinata services.\n *\n * This function allows you to generate a new API key with specific permissions\n * for use with Pinata's IPFS pinning services. It's useful for creating keys\n * with limited access or for specific applications.\n *\n * @async\n * @function createKey\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {KeyOptions} options - The options for creating a new API key.\n * @param {string} options.keyName - The name to assign to the new API key.\n * @param {KeyPermissions} options.permissions - The permissions to assign to the new key.\n * @param {number} [options.maxUses] - Optional. The maximum number of times the key can be used.\n * @returns {Promise<KeyResponse>} A promise that resolves to an object containing the new API key details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the key creation process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const key = await pinata.keys.create({\n *   keyName: \"user 1\",\n *   permissions: {\n *     admin: true,\n *   },\n *   maxUses: 1,\n * });\n */\n\nimport type { PinataConfig, KeyOptions, KeyResponse } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const createKey = async (\n\tconfig: PinataConfig | undefined,\n\toptions: KeyOptions,\n): Promise<KeyResponse> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/createKey\";\n\n\tconst data = JSON.stringify(options);\n\n\ttry {\n\t\tconst request = await fetch(\"https://api.pinata.cloud/v3/pinata/keys\", {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: headers,\n\t\t\tbody: data,\n\t\t});\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: KeyResponse = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing createKey: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while creating API key\");\n\t}\n};\n","/**\n * Retrieves a list of API keys associated with the Pinata account.\n *\n * This function allows you to fetch and optionally filter the API keys linked to your Pinata account.\n * It's useful for managing your API keys, checking their status, or auditing key usage.\n *\n * @async\n * @function listKeys\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {KeyListQuery} [options] - Optional query parameters to filter the list of keys.\n * @param {number} [options.offset] - The number of items to skip before starting to collect the result set.\n * @param {boolean} [options.revoked] - If true, includes revoked keys in the results.\n * @param {boolean} [options.limitedUse] - If true, only returns keys with usage limits.\n * @param {boolean} [options.exhausted] - If true, only returns keys that have reached their usage limit.\n * @param {string} [options.name] - Filters keys by name (partial match).\n * @returns {Promise<KeyListItem[]>} A promise that resolves to an array of key objects matching the query.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the key listing process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const keys = await pinata.keys\n *   .list()\n *   .name(\"Admin\")\n *   .revoked(false)\n */\n\nimport type {\n\tKeyListItem,\n\tKeyListQuery,\n\tKeyListResponse,\n\tPinataConfig,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const listKeys = async (\n\tconfig: PinataConfig | undefined,\n\toptions?: KeyListQuery,\n): Promise<KeyListItem[]> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/listKeys\";\n\n\tconst params = new URLSearchParams();\n\n\tif (options) {\n\t\tconst { offset, name, revoked, limitedUse, exhausted } = options;\n\n\t\tif (offset) params.append(\"offset\", offset.toString());\n\t\tif (revoked !== undefined) params.append(\"revoked\", revoked.toString());\n\t\tif (limitedUse !== undefined)\n\t\t\tparams.append(\"limitedUse\", limitedUse.toString());\n\t\tif (exhausted !== undefined)\n\t\t\tparams.append(\"exhausted\", exhausted.toString());\n\t\tif (name) params.append(\"name\", name);\n\t}\n\n\tconst url = `https://api.pinata.cloud/v3/pinata/keys?${params.toString()}`;\n\n\ttry {\n\t\tconst request = await fetch(url, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: headers,\n\t\t});\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: KeyListResponse = await request.json();\n\t\treturn res.keys;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing listKeys: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while listing API keys\");\n\t}\n};\n","/**\n * Revokes multiple API keys from the Pinata account.\n *\n * This function allows you to revoke (invalidate) multiple API keys at once.\n * It's useful for security purposes, such as when keys may have been compromised\n * or are no longer needed.\n *\n * @async\n * @function revokeKeys\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string[]} keys - An array of API key strings to be revoked.\n * @returns {Promise<RevokeKeyResponse[]>} A promise that resolves to an array of objects,\n *   each containing the status of the revocation attempt for each key.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the key revocation process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const revoke = await pinata.keys.revoke([\n *  \"94566af5e63833e260be\"\n * ]);\n */\n\nimport type { PinataConfig, RevokeKeyResponse } from \"../types\";\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nconst wait = (milliseconds: number): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\tsetTimeout(resolve, milliseconds);\n\t});\n};\n\nexport const revokeKeys = async (\n\tconfig: PinataConfig | undefined,\n\tkeys: string[],\n): Promise<RevokeKeyResponse[]> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/revokeKeys\";\n\n\tconst responses: RevokeKeyResponse[] = [];\n\n\tfor (const key of keys) {\n\t\ttry {\n\t\t\tconst request = await fetch(\n\t\t\t\t`https://api.pinata.cloud/v3/pinata/keys/${key}`,\n\t\t\t\t{\n\t\t\t\t\tmethod: \"PUT\",\n\t\t\t\t\theaders: headers,\n\t\t\t\t},\n\t\t\t);\n\n\t\t\tawait wait(300);\n\n\t\t\tif (!request.ok) {\n\t\t\t\tconst errorData = await request.json();\n\t\t\t\tif (request.status === 401) {\n\t\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\t\trequest.status,\n\t\t\t\t\t\terrorData,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tthrow new NetworkError(\n\t\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconst result: string = await request.json();\n\t\t\tresponses.push({\n\t\t\t\tkey: key,\n\t\t\t\tstatus: result,\n\t\t\t});\n\t\t} catch (error) {\n\t\t\tlet errorMessage: string;\n\n\t\t\tif (error instanceof PinataError) {\n\t\t\t\terrorMessage = error.message;\n\t\t\t} else if (error instanceof Error) {\n\t\t\t\terrorMessage = `Error revoking key ${key}: ${error.message}`;\n\t\t\t} else {\n\t\t\t\terrorMessage = `An unknown error occurred while revoking key ${key}`;\n\t\t\t}\n\n\t\t\tresponses.push({\n\t\t\t\tkey: key,\n\t\t\t\tstatus: errorMessage,\n\t\t\t});\n\t\t}\n\t}\n\n\treturn responses;\n};\n","/**\n * Creates a new group in Pinata for organizing pinned content.\n *\n * This function allows you to create a new group in your Pinata account.\n * Groups can be used to organize and manage your pinned content more effectively.\n *\n * @async\n * @function createGroup\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {GroupOptions} options - The options for creating a new group.\n * @param {string} options.name - The name of the group to be created.\n * @returns {Promise<GroupResponseItem>} A promise that resolves to an object containing details of the created group.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the group creation process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const group = await pinata.groups.create({\n *\tname: \"My New Group\",\n * });\n */\n\nimport type { PinataConfig, GroupOptions, GroupResponseItem } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const createGroup = async (\n\tconfig: PinataConfig | undefined,\n\toptions: GroupOptions,\n): Promise<GroupResponseItem> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst data = JSON.stringify(options);\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/createGroup\";\n\n\ttry {\n\t\tconst request = await fetch(\"https://api.pinata.cloud/groups\", {\n\t\t\tmethod: \"POST\",\n\t\t\theaders: headers,\n\t\t\tbody: data,\n\t\t});\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: GroupResponseItem = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing createGroup: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while creating a group\");\n\t}\n};\n","/**\n * Retrieves a list of groups from Pinata.\n *\n * This function fetches a list of groups associated with your Pinata account.\n * It supports pagination and filtering by name.\n *\n * @async\n * @function listGroups\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {GroupQueryOptions} [options] - Optional query parameters to filter and paginate the results.\n * @param {number} [options.offset] - The number of items to skip before starting to collect the result set.\n * @param {string} [options.nameContains] - Filter groups by name (case-insensitive partial match).\n * @param {number} [options.limit] - The numbers of items to return.\n * @returns {Promise<GroupResponseItem[]>} A promise that resolves to an array of group objects.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the group listing process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const groups = await pinata.groups\n *   .list()\n *   .name(\"Greetings\");\n */\n\nimport type {\n\tPinataConfig,\n\tGroupResponseItem,\n\tGroupQueryOptions,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const listGroups = async (\n\tconfig: PinataConfig | undefined,\n\toptions?: GroupQueryOptions,\n): Promise<GroupResponseItem[]> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/listGroups\";\n\n\tconst params = new URLSearchParams();\n\n\tif (options) {\n\t\tconst { offset, nameContains, limit } = options;\n\n\t\tif (offset) params.append(\"offset\", offset.toString());\n\t\tif (nameContains !== undefined)\n\t\t\tparams.append(\"nameContains\", nameContains.toString());\n\t\tif (limit !== undefined) params.append(\"limit\", limit.toString());\n\t}\n\n\tconst url = `https://api.pinata.cloud/groups?${params.toString()}`;\n\n\ttry {\n\t\tconst request = await fetch(url, {\n\t\t\tmethod: \"GET\",\n\t\t\theaders: headers,\n\t\t});\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: GroupResponseItem[] = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing listGroups: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while listing groups\");\n\t}\n};\n","/**\n * Retrieves information about a specific group from Pinata.\n *\n * This function fetches details about a group in your Pinata account using its ID.\n * It provides information such as the group's name, creation date, and last update time.\n *\n * @async\n * @function getGroup\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {GetGroupOptions} options - The options for retrieving a group.\n * @param {string} options.groupId - The ID of the group to retrieve.\n * @returns {Promise<GroupResponseItem>} A promise that resolves to an object containing the group's details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the group retrieval process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const groups = await pinata.groups.get({\n *\tgroupId: \"3778c10d-452e-4def-8299-ee6bc548bdb0\",\n * });\n */\n\nimport type {\n\tPinataConfig,\n\tGroupResponseItem,\n\tGetGroupOptions,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const getGroup = async (\n\tconfig: PinataConfig | undefined,\n\toptions: GetGroupOptions,\n): Promise<GroupResponseItem> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/getGroup\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/groups/${options.groupId}`,\n\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: headers,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: GroupResponseItem = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing getGroup: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while getting info for a group\",\n\t\t);\n\t}\n};\n","/**\n * Adds one or more CIDs (Content Identifiers) to a specified Pinata group.\n *\n * This function allows you to associate multiple CIDs with a group in Pinata,\n * which can be useful for organizing and managing your pinned content.\n *\n * @async\n * @function addToGroup\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {GroupCIDOptions} options - The options for adding CIDs to a group.\n * @param {string} options.groupId - The ID of the group to add the CIDs to.\n * @param {string[]} options.cids - An array of CIDs to add to the group.\n * @returns {Promise<string>} A promise that resolves to a string confirming the addition.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const group = await pinata.groups.addCids({\n * \tgroupId: \"3778c10d-452e-4def-8299-ee6bc548bdb0\",\n * \tcids: [\"QmVLwvmGehsrNEvhcCnnsw5RQNseohgEkFNN1848zNzdng\"],\n * });\n */\nimport type { GroupCIDOptions, PinataConfig } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const addToGroup = async (\n\tconfig: PinataConfig | undefined,\n\toptions: GroupCIDOptions,\n): Promise<string> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst data = JSON.stringify({\n\t\tcids: options.cids,\n\t});\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/addToGroup\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/groups/${options.groupId}/cids`,\n\t\t\t{\n\t\t\t\tmethod: \"PUT\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: string = await request.text();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing addToGroup: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while adding CIDs to group\",\n\t\t);\n\t}\n};\n","/**\n * Updates the information of a specified group in Pinata.\n *\n * This function allows you to modify the name of an existing group in your Pinata account.\n * It's useful for renaming groups to better organize your pinned content.\n *\n * @async\n * @function updateGroup\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {UpdateGroupOptions} options - The options for updating a group.\n * @param {string} options.groupId - The ID of the group to be updated.\n * @param {string} options.name - The new name for the group.\n * @returns {Promise<GroupResponseItem>} A promise that resolves to an object containing the updated group's details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the group update process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const groups = await pinata.groups.update({\n *\tgroupId: \"3778c10d-452e-4def-8299-ee6bc548bdb0\",\n *\tname: \"My New Group 2\"\n * });\n */\n\nimport type {\n\tPinataConfig,\n\tGroupResponseItem,\n\tUpdateGroupOptions,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const updateGroup = async (\n\tconfig: PinataConfig | undefined,\n\toptions: UpdateGroupOptions,\n): Promise<GroupResponseItem> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst data = JSON.stringify({\n\t\tname: options.name,\n\t});\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/updateGroup\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/groups/${options.groupId}`,\n\t\t\t{\n\t\t\t\tmethod: \"PUT\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: GroupResponseItem = await request.json();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing updateGroup: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while updating group\");\n\t}\n};\n","/**\n * Removes one or more CIDs (Content Identifiers) from a specified Pinata group.\n *\n * This function allows you to disassociate multiple CIDs from a group in Pinata.\n * It's useful for managing the content within your groups without deleting the actual files.\n *\n * @async\n * @function removeFromGroup\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {GroupCIDOptions} options - The options for removing CIDs from a group.\n * @param {string} options.groupId - The ID of the group to remove the CIDs from.\n * @param {string[]} options.cids - An array of CIDs to remove from the group.\n * @returns {Promise<string>} A promise that resolves to a string confirming the removal.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the process.\n *\n * @example\n *import { PinataSDK } from \"pinata\";\n *\n *const pinata = new PinataSDK({\n *  pinataJwt: process.env.PINATA_JWT!,\n *  pinataGateway: \"example-gateway.mypinata.cloud\",\n *});\n *\n *const group = await pinata.groups.removeCids({\n *\tgroupId: \"3778c10d-452e-4def-8299-ee6bc548bdb0\",\n *\tcids: [\"QmVLwvmGehsrNEvhcCnnsw5RQNseohgEkFNN1848zNzdng\"],\n *});\n */\n\nimport type { GroupCIDOptions, PinataConfig } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const removeFromGroup = async (\n\tconfig: PinataConfig | undefined,\n\toptions: GroupCIDOptions,\n): Promise<string> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/removeFromGroup\";\n\n\tconst data = JSON.stringify({\n\t\tcids: options.cids,\n\t});\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/groups/${options.groupId}/cids`,\n\t\t\t{\n\t\t\t\tmethod: \"DELETE\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: string = await request.text();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(\n\t\t\t\t`Error processing removeFromGroup: ${error.message}`,\n\t\t\t);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while removing CIDs from a group\",\n\t\t);\n\t}\n};\n","/**\n * Deletes a specified group from Pinata.\n *\n * This function allows you to remove a group from your Pinata account.\n * Note that deleting a group does not delete the files within the group,\n * it only removes the group association.\n *\n * @async\n * @function deleteGroup\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {GetGroupOptions} options - The options for deleting a group.\n * @param {string} options.groupId - The ID of the group to be deleted.\n * @returns {Promise<string>} A promise that resolves to a string confirming the deletion.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the group deletion process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const groups = await pinata.groups.delete({\n *\tgroupId: \"3778c10d-452e-4def-8299-ee6bc548bdb0\",\n * });\n */\n\nimport type { GetGroupOptions, PinataConfig } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const deleteGroup = async (\n\tconfig: PinataConfig | undefined,\n\toptions: GetGroupOptions,\n): Promise<string> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/deleteGroup\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/groups/${options.groupId}`,\n\t\t\t{\n\t\t\t\tmethod: \"DELETE\",\n\t\t\t\theaders: headers,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res: string = await request.text();\n\t\treturn res;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing deleteGroup: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\"An unknown error occurred while deleting a group\");\n\t}\n};\n","/**\n * Adds a signature to a specific Content Identifier (CID) on Pinata.\n *\n * This function allows you to add a cryptographic signature to a file identified by its CID.\n * It's useful for verifying ownership or authenticity of content stored on IPFS via Pinata.\n *\n * @async\n * @function addSignature\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {SignatureOptions} options - Options for adding the signature.\n * @param {string} options.cid - The Content Identifier (CID) of the file to be signed.\n * @param {string} options.signature - The cryptographic signature to be added.\n * @returns {Promise<SignatureResponse>} A promise that resolves to an object containing the signature details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {PinataError} If the user is unauthorized to sign the file or if the file already has a signature.\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the signature addition process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const signature = await pinata.signatures.add({\n *\tcid: \"QmXGeVy9dVwfuFJmvbzz8y4dYK1TdxXbDGzwbNuyZ5xXSU\",\n *\tsignature: \"0x1ba6c2a8412dc9b0be37b013ea5bddd97251dab4d435cc9c4c7bcf331d4017ca2de07485ad6a15ce60d3700cee802787bc7ede0c112c7843f702bb1e71b750911b\"\n * })\n */\n\nimport type {\n\tSignatureOptions,\n\tPinataConfig,\n\tSignatureResponse,\n} from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const addSignature = async (\n\tconfig: PinataConfig | undefined,\n\toptions: SignatureOptions,\n): Promise<SignatureResponse> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst data = JSON.stringify({\n\t\tsignature: options.signature,\n\t});\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/addSignature\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/v3/ipfs/signature/${options.cid}`,\n\t\t\t{\n\t\t\t\tmethod: \"POST\",\n\t\t\t\theaders: headers,\n\t\t\t\tbody: data,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (request.status === 403) {\n\t\t\t\tthrow new PinataError(\n\t\t\t\t\t\"Unauthorized signing, you must be the original owner of the file and it must not have a signature\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res = await request.json();\n\t\treturn res.data;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing addSignature: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while adding signature to CID\",\n\t\t);\n\t}\n};\n","/**\n * Retrieves the signature associated with a specific Content Identifier (CID) from Pinata.\n *\n * This function allows you to fetch the cryptographic signature associated with a file\n * identified by its CID. It's useful for verifying the authenticity or ownership of\n * content stored on IPFS via Pinata.\n *\n * @async\n * @function getSignature\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string} cid - The Content Identifier (CID) of the file whose signature is to be retrieved.\n * @returns {Promise<SignatureResponse>} A promise that resolves to an object containing the signature details.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the signature retrieval process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const signature = await pinata.signatures.get(\"QmXGeVy9dVwfuFJmvbzz8y4dYK1TdxXbDGzwbNuyZ5xXSU\"\n )\n */\n\nimport type { PinataConfig, SignatureResponse } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const getSignature = async (\n\tconfig: PinataConfig | undefined,\n\tcid: string,\n): Promise<SignatureResponse> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/getSignature\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/v3/ipfs/signature/${cid}`,\n\t\t\t{\n\t\t\t\tmethod: \"GET\",\n\t\t\t\theaders: headers,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\n\t\tconst res = await request.json();\n\t\treturn res.data;\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing getSignature: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while fetching signature for CID\",\n\t\t);\n\t}\n};\n","/**\n * Removes the signature associated with a specific Content Identifier (CID) from Pinata.\n *\n * This function allows you to delete the cryptographic signature associated with a file\n * identified by its CID. It's useful for managing ownership claims or updating the\n * authenticity status of content stored on IPFS via Pinata.\n *\n * @async\n * @function removeSignature\n * @param {PinataConfig | undefined} config - The Pinata configuration object containing the JWT.\n * @param {string} cid - The Content Identifier (CID) of the file whose signature is to be removed.\n * @returns {Promise<string>} A promise that resolves to \"OK\" if the signature was successfully removed.\n * @throws {ValidationError} If the Pinata configuration or JWT is missing.\n * @throws {AuthenticationError} If the authentication fails (e.g., invalid JWT).\n * @throws {NetworkError} If there's a network-related error during the API request.\n * @throws {PinataError} For any other errors that occur during the signature removal process.\n *\n * @example\n * import { PinataSDK } from \"pinata\";\n *\n * const pinata = new PinataSDK({\n *   pinataJwt: process.env.PINATA_JWT!,\n *   pinataGateway: \"example-gateway.mypinata.cloud\",\n * });\n *\n * const signature = await pinata.signatures.delete(\"QmXGeVy9dVwfuFJmvbzz8y4dYK1TdxXbDGzwbNuyZ5xXSU\"\n )\n */\n\nimport type { PinataConfig } from \"../types\";\n\nimport {\n\tPinataError,\n\tNetworkError,\n\tAuthenticationError,\n\tValidationError,\n} from \"../../utils/custom-errors\";\n\nexport const removeSignature = async (\n\tconfig: PinataConfig | undefined,\n\tcid: string,\n): Promise<string> => {\n\tif (!config || !config.pinataJwt) {\n\t\tthrow new ValidationError(\"Pinata configuration or JWT is missing\");\n\t}\n\n\tconst headers: Record<string, string> = {\n\t\t\"Content-Type\": \"application/json\",\n\t\tAuthorization: `Bearer ${config?.pinataJwt}`,\n\t};\n\n\tif (config.customHeaders) {\n\t\tObject.assign(headers, config.customHeaders);\n\t}\n\n\t// biome-ignore lint/complexity/useLiteralKeys: non-issue\n\theaders[\"Source\"] = headers[\"Source\"] || \"sdk/removeSignature\";\n\n\ttry {\n\t\tconst request = await fetch(\n\t\t\t`https://api.pinata.cloud/v3/ipfs/signature/${cid}`,\n\t\t\t{\n\t\t\t\tmethod: \"DELETE\",\n\t\t\t\theaders: headers,\n\t\t\t},\n\t\t);\n\n\t\tif (!request.ok) {\n\t\t\tconst errorData = await request.json();\n\t\t\tif (request.status === 401) {\n\t\t\t\tthrow new AuthenticationError(\n\t\t\t\t\t\"Authentication failed\",\n\t\t\t\t\trequest.status,\n\t\t\t\t\terrorData,\n\t\t\t\t);\n\t\t\t}\n\t\t\tthrow new NetworkError(\n\t\t\t\t`HTTP error! status: ${request.status}`,\n\t\t\t\trequest.status,\n\t\t\t\terrorData,\n\t\t\t);\n\t\t}\n\t\treturn \"OK\";\n\t} catch (error) {\n\t\tif (error instanceof PinataError) {\n\t\t\tthrow error;\n\t\t}\n\t\tif (error instanceof Error) {\n\t\t\tthrow new PinataError(`Error processing addSignature: ${error.message}`);\n\t\t}\n\t\tthrow new PinataError(\n\t\t\t\"An unknown error occurred while adding signature to CID\",\n\t\t);\n\t}\n};\n","import type {\n\tFileObject,\n\tPinByCIDResponse,\n\tPinListItem,\n\tPinListQuery,\n\tPinResponse,\n\tPinataConfig,\n\tPinataMetadata,\n\tPinataMetadataUpdate,\n\tUploadCIDOptions,\n\tUploadOptions,\n\tGetCIDResponse,\n\tPinJobQuery,\n\tPinJobItem,\n\tKeyOptions,\n\tKeyResponse,\n\tKeyListQuery,\n\tKeyListItem,\n\tGroupOptions,\n\tGroupResponseItem,\n\tUpdateGroupOptions,\n\tGroupCIDOptions,\n\tGroupQueryOptions,\n\tGetGroupOptions,\n\tAuthTestResponse,\n\tUnpinResponse,\n\tRevokeKeyResponse,\n\tSignatureOptions,\n\tSignatureResponse,\n} from \"./types\";\nimport { testAuthentication } from \"./authentication/testAuthentication\";\nimport { uploadFile } from \"./pinning/file\";\nimport { uploadFileArray } from \"./pinning/fileArray\";\nimport { uploadBase64 } from \"./pinning/base64\";\nimport { uploadUrl } from \"./pinning/url\";\nimport { uploadJson } from \"./pinning/json\";\nimport { uploadCid } from \"./pinning/cid\";\nimport { unpinFile } from \"./pinning/unpin\";\nimport { listFiles } from \"./data/listFiles\";\nimport { updateMetadata } from \"./data/updateMetadata\";\nimport { getCid } from \"./gateway/getCid\";\nimport { convertIPFSUrl } from \"./gateway/convertIPFSUrl\";\nimport { pinJobs } from \"./data/pinJobs\";\nimport { pinnedFileCount } from \"./data/pinnedFileUsage\";\nimport { totalStorageUsage } from \"./data/totalStorageUsage\";\nimport { createKey } from \"./keys/createKey\";\nimport { listKeys } from \"./keys/listKeys\";\nimport { revokeKeys } from \"./keys/revokeKeys\";\nimport { createGroup } from \"./groups/createGroup\";\nimport { listGroups } from \"./groups/listGroups\";\nimport { getGroup } from \"./groups/getGroup\";\nimport { addToGroup } from \"./groups/addToGroup\";\nimport { updateGroup } from \"./groups/updateGroup\";\nimport { removeFromGroup } from \"./groups/removeFromGroup\";\nimport { deleteGroup } from \"./groups/deleteGroup\";\nimport { addSignature } from \"./signatures/addSignature\";\nimport { getSignature } from \"./signatures/getSignature\";\nimport { removeSignature } from \"./signatures/removeSignature\";\n\nconst formatConfig = (config: PinataConfig | undefined) => {\n\tlet gateway = config?.pinataGateway;\n\tif (config && gateway) {\n\t\tif (gateway && !gateway.startsWith(\"https://\")) {\n\t\t\tgateway = `https://${gateway}`;\n\t\t}\n\t\tconfig.pinataGateway = gateway;\n\t}\n\treturn config;\n};\n\nexport class PinataSDK {\n\tconfig: PinataConfig | undefined;\n\tupload: Upload;\n\tgateways: Gateways;\n\tusage: Usage;\n\tkeys: Keys;\n\tgroups: Groups;\n\tsignatures: Signatures;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t\tthis.upload = new Upload(this.config);\n\t\tthis.gateways = new Gateways(this.config);\n\t\tthis.usage = new Usage(this.config);\n\t\tthis.keys = new Keys(this.config);\n\t\tthis.groups = new Groups(this.config);\n\t\tthis.signatures = new Signatures(this.config);\n\t}\n\n\ttestAuthentication(): Promise<AuthTestResponse> {\n\t\treturn testAuthentication(this.config);\n\t}\n\n\tunpin(files: string[]): Promise<UnpinResponse[]> {\n\t\treturn unpinFile(this.config, files);\n\t}\n\n\tlistFiles(): FilterFiles {\n\t\treturn new FilterFiles(this.config);\n\t}\n\n\tupdateMetadata(options: PinataMetadataUpdate): Promise<string> {\n\t\treturn updateMetadata(this.config, options);\n\t}\n\n\tpinJobs(): FilterPinJobs {\n\t\treturn new FilterPinJobs(this.config);\n\t}\n}\n\nclass UploadBuilder<T> {\n\tprivate config: PinataConfig | undefined;\n\tprivate uploadFunction: (\n\t\tconfig: PinataConfig | undefined,\n\t\t...args: any[]\n\t) => Promise<T>;\n\tprivate args: any[];\n\tprivate metadata: PinataMetadata | undefined;\n\tprivate keys: string | undefined;\n\tprivate peerAddresses: string[] | undefined;\n\tprivate version: 0 | 1 | undefined;\n\tprivate groupId: string | undefined;\n\n\tconstructor(\n\t\tconfig: PinataConfig | undefined,\n\t\tuploadFunction: (\n\t\t\tconfig: PinataConfig | undefined,\n\t\t\t...args: any[]\n\t\t) => Promise<T>,\n\t\t...args: any[]\n\t) {\n\t\tthis.config = config;\n\t\tthis.uploadFunction = uploadFunction;\n\t\tthis.args = args;\n\t\tthis.version = 1;\n\t}\n\n\taddMetadata(metadata: PinataMetadata): UploadBuilder<T> {\n\t\tthis.metadata = metadata;\n\t\treturn this;\n\t}\n\n\tkey(jwt: string): UploadBuilder<T> {\n\t\tthis.keys = jwt;\n\t\treturn this;\n\t}\n\n\tcidVersion(v: 0 | 1): UploadBuilder<T> {\n\t\tthis.version = v;\n\t\treturn this;\n\t}\n\n\tgroup(groupId: string): UploadBuilder<T> {\n\t\tthis.groupId = groupId;\n\t\treturn this;\n\t}\n\n\tpeerAddress(peerAddresses: string[]): UploadBuilder<T> {\n\t\tthis.peerAddresses = peerAddresses;\n\t\treturn this;\n\t}\n\n\tthen<TResult1 = T, TResult2 = never>(\n\t\tonfulfilled?:\n\t\t\t| ((value: T) => TResult1 | PromiseLike<TResult1>)\n\t\t\t| null\n\t\t\t| undefined,\n\t\tonrejected?:\n\t\t\t| ((reason: any) => TResult2 | PromiseLike<TResult2>)\n\t\t\t| null\n\t\t\t| undefined,\n\t): Promise<TResult1 | TResult2> {\n\t\tconst options: UploadOptions = this.args[this.args.length - 1] || {};\n\t\tif (this.metadata) {\n\t\t\toptions.metadata = this.metadata;\n\t\t}\n\t\tif (this.keys) {\n\t\t\toptions.keys = this.keys;\n\t\t}\n\t\tif (this.groupId) {\n\t\t\toptions.groupId = this.groupId;\n\t\t}\n\t\tif (this.version) {\n\t\t\toptions.cidVersion = this.version;\n\t\t}\n\t\tif (this.peerAddresses && \"peerAddresses\" in options) {\n\t\t\toptions.peerAddresses = this.peerAddresses;\n\t\t}\n\t\tthis.args[this.args.length - 1] = options;\n\t\treturn this.uploadFunction(this.config, ...this.args).then(\n\t\t\tonfulfilled,\n\t\t\tonrejected,\n\t\t);\n\t}\n}\n\nclass Upload {\n\tconfig: PinataConfig | undefined;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t}\n\n\tfile(file: FileObject, options?: UploadOptions): UploadBuilder<PinResponse> {\n\t\treturn new UploadBuilder(this.config, uploadFile, file, options);\n\t}\n\n\tfileArray(\n\t\tfiles: FileObject[],\n\t\toptions?: UploadOptions,\n\t): UploadBuilder<PinResponse> {\n\t\treturn new UploadBuilder(this.config, uploadFileArray, files, options);\n\t}\n\n\tbase64(\n\t\tbase64String: string,\n\t\toptions?: UploadOptions,\n\t): UploadBuilder<PinResponse> {\n\t\treturn new UploadBuilder(this.config, uploadBase64, base64String, options);\n\t}\n\n\turl(url: string, options?: UploadOptions): UploadBuilder<PinResponse> {\n\t\treturn new UploadBuilder(this.config, uploadUrl, url, options);\n\t}\n\n\tjson(data: object, options?: UploadOptions): UploadBuilder<PinResponse> {\n\t\treturn new UploadBuilder(this.config, uploadJson, data, options);\n\t}\n\n\tcid(\n\t\tcid: string,\n\t\toptions?: UploadCIDOptions,\n\t): UploadBuilder<PinByCIDResponse> {\n\t\treturn new UploadBuilder(this.config, uploadCid, cid, options);\n\t}\n}\n\nclass FilterFiles {\n\tprivate config: PinataConfig | undefined;\n\tprivate query: PinListQuery = {};\n\t// rate limit vars\n\tprivate requestCount = 0;\n\tprivate lastRequestTime = 0;\n\tprivate readonly MAX_REQUESTS_PER_MINUTE = 30;\n\tprivate readonly MINUTE_IN_MS = 60000;\n\n\tconstructor(config: PinataConfig | undefined) {\n\t\tthis.config = config;\n\t}\n\n\tcid(cid: string): FilterFiles {\n\t\tthis.query.cid = cid;\n\t\treturn this;\n\t}\n\n\tpinStart(date: string): FilterFiles {\n\t\tthis.query.pinStart = date;\n\t\treturn this;\n\t}\n\n\tpinEnd(date: string): FilterFiles {\n\t\tthis.query.pinEnd = date;\n\t\treturn this;\n\t}\n\n\tpinSizeMin(size: number): FilterFiles {\n\t\tthis.query.pinSizeMin = size;\n\t\treturn this;\n\t}\n\n\tpinSizeMax(size: number): FilterFiles {\n\t\tthis.query.pinSizeMax = size;\n\t\treturn this;\n\t}\n\n\tpageLimit(limit: number): FilterFiles {\n\t\tthis.query.pageLimit = limit;\n\t\treturn this;\n\t}\n\n\tpageOffset(offset: number): FilterFiles {\n\t\tthis.query.pageOffset = offset;\n\t\treturn this;\n\t}\n\n\tname(name: string): FilterFiles {\n\t\tthis.query.name = name;\n\t\treturn this;\n\t}\n\n\tgroup(groupId: string): FilterFiles {\n\t\tthis.query.groupId = groupId;\n\t\treturn this;\n\t}\n\n\tkeyValue(\n\t\tkey: string,\n\t\tvalue: string | number,\n\t\toperator?: PinListQuery[\"operator\"],\n\t): FilterFiles {\n\t\tthis.query.key = key;\n\t\tthis.query.value = value;\n\t\tif (operator) {\n\t\t\tthis.query.operator = operator;\n\t\t}\n\t\treturn this;\n\t}\n\n\tthen(onfulfilled?: ((value: PinListItem[]) => any) | null): Promise<any> {\n\t\treturn listFiles(this.config, this.query).then(onfulfilled);\n\t}\n\n\t// rate limit, hopefully temporary?\n\tprivate async rateLimit(): Promise<void> {\n\t\tthis.requestCount++;\n\t\tconst now = Date.now();\n\t\tif (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n\t\t\tconst timePassedSinceLastRequest = now - this.lastRequestTime;\n\t\t\tif (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n\t\t\t\tconst delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, delayTime));\n\t\t\t}\n\t\t\tthis.requestCount = 0;\n\t\t}\n\t\tthis.lastRequestTime = Date.now();\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncGenerator<PinListItem, void, unknown> {\n\t\tlet hasMore = true;\n\t\tlet offset = 0;\n\t\tconst limit = this.query.pageLimit || 10;\n\n\t\twhile (hasMore) {\n\t\t\tawait this.rateLimit(); // applying rate limit\n\t\t\tthis.query.pageOffset = offset;\n\t\t\tthis.query.pageLimit = limit;\n\n\t\t\tconst items = await listFiles(this.config, this.query);\n\n\t\t\tfor (const item of items) {\n\t\t\t\tyield item;\n\t\t\t}\n\n\t\t\tif (items.length === 0) {\n\t\t\t\thasMore = false;\n\t\t\t} else {\n\t\t\t\toffset += items.length;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync all(): Promise<PinListItem[]> {\n\t\tconst allItems: PinListItem[] = [];\n\t\tfor await (const item of this) {\n\t\t\tallItems.push(item);\n\t\t}\n\t\treturn allItems;\n\t}\n}\n\nclass Gateways {\n\tconfig: PinataConfig | undefined;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t}\n\n\tget(cid: string): Promise<GetCIDResponse> {\n\t\treturn getCid(this.config, cid);\n\t}\n\n\tconvert(url: string): Promise<string> {\n\t\treturn convertIPFSUrl(this.config, url);\n\t}\n}\n\nclass FilterPinJobs {\n\tprivate config: PinataConfig | undefined;\n\tprivate query: PinJobQuery = {};\n\t// rate limit vars\n\tprivate requestCount = 0;\n\tprivate lastRequestTime = 0;\n\tprivate readonly MAX_REQUESTS_PER_MINUTE = 30;\n\tprivate readonly MINUTE_IN_MS = 60000;\n\n\tconstructor(config: PinataConfig | undefined) {\n\t\tthis.config = config;\n\t}\n\n\tcid(cid: string): FilterPinJobs {\n\t\tthis.query.ipfs_pin_hash = cid;\n\t\treturn this;\n\t}\n\n\tstatus(\n\t\tstatus:\n\t\t\t| \"prechecking\"\n\t\t\t| \"retrieving\"\n\t\t\t| \"expired\"\n\t\t\t| \"over_free_limit\"\n\t\t\t| \"over_max_size\"\n\t\t\t| \"invalid_object\"\n\t\t\t| \"bad_host_node\",\n\t): FilterPinJobs {\n\t\tthis.query.status = status;\n\t\treturn this;\n\t}\n\n\tpageLimit(limit: number): FilterPinJobs {\n\t\tthis.query.limit = limit;\n\t\treturn this;\n\t}\n\n\tpageOffset(offset: number): FilterPinJobs {\n\t\tthis.query.offset = offset;\n\t\treturn this;\n\t}\n\n\tsort(sort: \"ASC\" | \"DSC\"): FilterPinJobs {\n\t\tthis.query.sort = sort;\n\t\treturn this;\n\t}\n\n\tthen(onfulfilled?: ((value: PinJobItem[]) => any) | null): Promise<any> {\n\t\treturn pinJobs(this.config, this.query).then(onfulfilled);\n\t}\n\n\t// rate limit, hopefully temporary?\n\tprivate async rateLimit(): Promise<void> {\n\t\tthis.requestCount++;\n\t\tconst now = Date.now();\n\t\tif (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n\t\t\tconst timePassedSinceLastRequest = now - this.lastRequestTime;\n\t\t\tif (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n\t\t\t\tconst delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, delayTime));\n\t\t\t}\n\t\t\tthis.requestCount = 0;\n\t\t}\n\t\tthis.lastRequestTime = Date.now();\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncGenerator<PinJobItem, void, unknown> {\n\t\tlet hasMore = true;\n\t\tlet offset = 0;\n\t\tconst limit = this.query.limit || 10;\n\n\t\twhile (hasMore) {\n\t\t\tawait this.rateLimit(); // applying rate limit\n\t\t\tthis.query.offset = offset;\n\t\t\tthis.query.limit = limit;\n\n\t\t\tconst items = await pinJobs(this.config, this.query);\n\n\t\t\tfor (const item of items) {\n\t\t\t\tyield item;\n\t\t\t}\n\n\t\t\tif (items.length === 0) {\n\t\t\t\thasMore = false;\n\t\t\t} else {\n\t\t\t\toffset += items.length;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync all(): Promise<PinJobItem[]> {\n\t\tconst allItems: PinJobItem[] = [];\n\t\tfor await (const item of this) {\n\t\t\tallItems.push(item);\n\t\t}\n\t\treturn allItems;\n\t}\n}\n\nclass Usage {\n\tconfig: PinataConfig | undefined;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t}\n\n\tpinnedFileCount(): Promise<number> {\n\t\treturn pinnedFileCount(this.config);\n\t}\n\n\ttotalStorageSize(): Promise<number> {\n\t\treturn totalStorageUsage(this.config);\n\t}\n}\n\nclass Keys {\n\tconfig: PinataConfig | undefined;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t}\n\n\tcreate(options: KeyOptions): Promise<KeyResponse> {\n\t\treturn createKey(this.config, options);\n\t}\n\n\tlist(): FilterKeys {\n\t\treturn new FilterKeys(this.config);\n\t}\n\n\trevoke(keys: string[]): Promise<RevokeKeyResponse[]> {\n\t\treturn revokeKeys(this.config, keys);\n\t}\n}\n\nclass FilterKeys {\n\tprivate config: PinataConfig | undefined;\n\tprivate query: KeyListQuery = {};\n\t// rate limit vars\n\tprivate requestCount = 0;\n\tprivate lastRequestTime = 0;\n\tprivate readonly MAX_REQUESTS_PER_MINUTE = 30;\n\tprivate readonly MINUTE_IN_MS = 60000;\n\n\tconstructor(config: PinataConfig | undefined) {\n\t\tthis.config = config;\n\t}\n\n\toffset(offset: number): FilterKeys {\n\t\tthis.query.offset = offset;\n\t\treturn this;\n\t}\n\n\trevoked(revoked: boolean): FilterKeys {\n\t\tthis.query.revoked = revoked;\n\t\treturn this;\n\t}\n\n\tlimitedUse(limitedUse: boolean): FilterKeys {\n\t\tthis.query.limitedUse = limitedUse;\n\t\treturn this;\n\t}\n\n\texhausted(exhausted: boolean): FilterKeys {\n\t\tthis.query.exhausted = exhausted;\n\t\treturn this;\n\t}\n\n\tname(name: string): FilterKeys {\n\t\tthis.query.name = name;\n\t\treturn this;\n\t}\n\n\tthen(onfulfilled?: ((value: KeyListItem[]) => any) | null): Promise<any> {\n\t\treturn listKeys(this.config, this.query).then(onfulfilled);\n\t}\n\n\t// rate limit, hopefully temporary?\n\tprivate async rateLimit(): Promise<void> {\n\t\tthis.requestCount++;\n\t\tconst now = Date.now();\n\t\tif (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n\t\t\tconst timePassedSinceLastRequest = now - this.lastRequestTime;\n\t\t\tif (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n\t\t\t\tconst delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, delayTime));\n\t\t\t}\n\t\t\tthis.requestCount = 0;\n\t\t}\n\t\tthis.lastRequestTime = Date.now();\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncGenerator<KeyListItem, void, unknown> {\n\t\tlet hasMore = true;\n\t\tlet offset = 0;\n\n\t\twhile (hasMore) {\n\t\t\tawait this.rateLimit(); // applying rate limit\n\t\t\tthis.query.offset = offset;\n\n\t\t\tconst items = await listKeys(this.config, this.query);\n\n\t\t\tfor (const item of items) {\n\t\t\t\tyield item;\n\t\t\t}\n\n\t\t\tif (items.length === 0) {\n\t\t\t\thasMore = false;\n\t\t\t} else {\n\t\t\t\toffset += items.length;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync all(): Promise<KeyListItem[]> {\n\t\tconst allItems: KeyListItem[] = [];\n\t\tfor await (const item of this) {\n\t\t\tallItems.push(item);\n\t\t}\n\t\treturn allItems;\n\t}\n}\n\nclass Groups {\n\tconfig: PinataConfig | undefined;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t}\n\n\tcreate(options: GroupOptions): Promise<GroupResponseItem> {\n\t\treturn createGroup(this.config, options);\n\t}\n\n\tlist(): FilterGroups {\n\t\treturn new FilterGroups(this.config);\n\t}\n\n\tget(options: GetGroupOptions): Promise<GroupResponseItem> {\n\t\treturn getGroup(this.config, options);\n\t}\n\n\taddCids(options: GroupCIDOptions): Promise<string> {\n\t\treturn addToGroup(this.config, options);\n\t}\n\n\tremoveCids(options: GroupCIDOptions): Promise<string> {\n\t\treturn removeFromGroup(this.config, options);\n\t}\n\n\tupdate(options: UpdateGroupOptions): Promise<GroupResponseItem> {\n\t\treturn updateGroup(this.config, options);\n\t}\n\n\tdelete(options: GetGroupOptions): Promise<string> {\n\t\treturn deleteGroup(this.config, options);\n\t}\n}\n\nclass FilterGroups {\n\tprivate config: PinataConfig | undefined;\n\tprivate query: GroupQueryOptions = {};\n\t// rate limit vars\n\tprivate requestCount = 0;\n\tprivate lastRequestTime = 0;\n\tprivate readonly MAX_REQUESTS_PER_MINUTE = 30;\n\tprivate readonly MINUTE_IN_MS = 60000;\n\n\tconstructor(config: PinataConfig | undefined) {\n\t\tthis.config = config;\n\t}\n\n\toffset(offset: number): FilterGroups {\n\t\tthis.query.offset = offset;\n\t\treturn this;\n\t}\n\n\tname(nameContains: string): FilterGroups {\n\t\tthis.query.nameContains = nameContains;\n\t\treturn this;\n\t}\n\n\tlimit(limit: number): FilterGroups {\n\t\tthis.query.limit = limit;\n\t\treturn this;\n\t}\n\n\tthen(\n\t\tonfulfilled?: ((value: GroupResponseItem[]) => any) | null,\n\t): Promise<any> {\n\t\treturn listGroups(this.config, this.query).then(onfulfilled);\n\t}\n\n\t// rate limit, hopefully temporary?\n\tprivate async rateLimit(): Promise<void> {\n\t\tthis.requestCount++;\n\t\tconst now = Date.now();\n\t\tif (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {\n\t\t\tconst timePassedSinceLastRequest = now - this.lastRequestTime;\n\t\t\tif (timePassedSinceLastRequest < this.MINUTE_IN_MS) {\n\t\t\t\tconst delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;\n\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, delayTime));\n\t\t\t}\n\t\t\tthis.requestCount = 0;\n\t\t}\n\t\tthis.lastRequestTime = Date.now();\n\t}\n\n\tasync *[Symbol.asyncIterator](): AsyncGenerator<\n\t\tGroupResponseItem,\n\t\tvoid,\n\t\tunknown\n\t> {\n\t\tlet hasMore = true;\n\t\tlet offset = 0;\n\n\t\twhile (hasMore) {\n\t\t\tawait this.rateLimit(); // applying rate limit\n\t\t\tthis.query.offset = offset;\n\n\t\t\tconst items = await listGroups(this.config, this.query);\n\n\t\t\tfor (const item of items) {\n\t\t\t\tyield item;\n\t\t\t}\n\n\t\t\tif (items.length === 0) {\n\t\t\t\thasMore = false;\n\t\t\t} else {\n\t\t\t\toffset += items.length;\n\t\t\t}\n\t\t}\n\t}\n\n\tasync all(): Promise<GroupResponseItem[]> {\n\t\tconst allItems: GroupResponseItem[] = [];\n\t\tfor await (const item of this) {\n\t\t\tallItems.push(item);\n\t\t}\n\t\treturn allItems;\n\t}\n}\n\nclass Signatures {\n\tconfig: PinataConfig | undefined;\n\n\tconstructor(config?: PinataConfig) {\n\t\tthis.config = formatConfig(config);\n\t}\n\n\tadd(options: SignatureOptions): Promise<SignatureResponse> {\n\t\treturn addSignature(this.config, options);\n\t}\n\n\tget(cid: string): Promise<SignatureResponse> {\n\t\treturn getSignature(this.config, cid);\n\t}\n\n\tdelete(cid: string): Promise<string> {\n\t\treturn removeSignature(this.config, cid);\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}