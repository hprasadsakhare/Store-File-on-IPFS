{"ast":null,"code":"/**\n * @packageDocumentation\n *\n * A suite of util methods that provides efficient validation.\n *\n * Detection of IPFS Paths and identifiers in URLs is a two-stage process:\n *\n * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates\n * 2. proper CID validation is applied to remove false-positives\n *\n * @example\n *\n * ```TypeScript\n * import * as isIPFS from 'is-ipfs'\n *\n * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.multihash('noop') // false\n *\n * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)\n * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)\n * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)\n * isIPFS.cid('noop') // false\n *\n * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true\n * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n *\n * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true\n * isIPFS.url('https://ipfs.io/ipns/github.com') // true\n * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true\n * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false\n * isIPFS.url('https://google.com') // false\n *\n * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true\n * isIPFS.path('/ipns/github.com') // true\n * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false\n *\n * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true\n * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('/ipns/github.com') // true\n * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.urlOrPath('https://google.com') // false\n *\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true\n *\n * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsPath('/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsPath('/ipns/github.com') // true\n *\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false\n *\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)\n * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)\n * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)\n *\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true\n * isIPFS.multiaddr('/ip6/::1/udp/1234') // true\n * isIPFS.multiaddr('ip6/::1/udp/1234') // false\n * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false\n *\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true\n * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)\n * ```\n */\nimport * as mafmt from '@multiformats/mafmt';\nimport { multiaddr } from '@multiformats/multiaddr';\nimport { URL } from 'iso-url';\nimport { base32 } from 'multiformats/bases/base32';\nimport { base58btc } from 'multiformats/bases/base58';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/;\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/;\nconst defaultProtocolMatch = 1;\nconst defaultHashMath = 2;\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/;\nconst subdomainIdMatch = 1;\nconst subdomainProtocolMatch = 2;\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;\nfunction isMultihash(hash) {\n  const formatted = convertToString(hash);\n  if (formatted === false) {\n    return false;\n  }\n  try {\n    Digest.decode(base58btc.decode(`z${formatted}`));\n  } catch {\n    return false;\n  }\n  return true;\n}\nfunction isMultiaddr(input) {\n  try {\n    return Boolean(multiaddr(input));\n  } catch {\n    return false;\n  }\n}\nfunction isBase32EncodedMultibase(hash) {\n  try {\n    let cid;\n    if (isString(hash)) {\n      cid = CID.parse(hash);\n    } else {\n      cid = CID.asCID(hash);\n    }\n    if (cid == null) {\n      return false;\n    }\n    base32.decode(cid.toString());\n  } catch {\n    return false;\n  }\n  return true;\n}\nfunction isCID(hash) {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash));\n    }\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash));\n    }\n    return Boolean(CID.asCID(hash)); // eslint-disable-line no-new\n  } catch {\n    return false;\n  }\n}\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr(input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input);\n}\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input);\n  if (formatted === false) {\n    return false;\n  }\n  const match = formatted.match(pattern);\n  if (match == null) {\n    return false;\n  }\n  if (match[protocolMatch] !== 'ipfs') {\n    return false;\n  }\n  let hash = match[hashMatch];\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase();\n  }\n  return isCID(hash);\n}\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input);\n  if (formatted === false) {\n    return false;\n  }\n  const match = formatted.match(pattern);\n  if (match == null) {\n    return false;\n  }\n  if (match[protocolMatch] !== 'ipns') {\n    return false;\n  }\n  let ipnsId = match[hashMatch];\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase();\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true;\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org → en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-');\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const {\n        hostname\n      } = new URL(`http://${ipnsId}`); // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname);\n    } catch (e) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * @param {any} input\n */\nfunction isString(input) {\n  return typeof input === 'string';\n}\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString(input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc');\n  }\n  if (isString(input)) {\n    return input;\n  }\n  return false;\n}\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS subdomain\n * (case-insensitive CIDv1) or `false` otherwise.\n */\nexport const ipfsSubdomain = url => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * Returns `true` if the provided `url` string looks like a valid IPNS subdomain\n * (CIDv1 with `libp2p-key` multicodec or something that looks like a FQDN, for\n * example `en.wikipedia-on-ipfs.org.ipns.localhost:8080`) or `false` otherwise.\n *\n * **Note:** `ipnsSubdomain` method works in offline mode: it does not perform\n * actual IPNS record lookup over DHT or other content routing method. It may\n * return false-positives:\n *\n * - To ensure IPNS record  exists, make a call to `/api/v0/name/resolve?arg=<ipnsid>`\n * - To ensure DNSLink exists, make a call to `/api/v0/dns?arg=<fqdn>`\n */\nexport const ipnsSubdomain = url => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS, looks like\n * an IPNS/DNSLink subdomain or `false` otherwise.\n */\nexport const subdomain = url => ipfsSubdomain(url) || ipnsSubdomain(url);\n/**\n * Returns `true` if the provided string is a valid IPFS url or `false`\n * otherwise.\n */\nexport const ipfsUrl = url => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url);\n/**\n * Returns `true` if the provided string is a valid IPNS url or `false`\n * otherwise.\n */\nexport const ipnsUrl = url => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url);\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or `false`\n * otherwise.\n */\nexport const url = url => ipfsUrl(url) || ipnsUrl(url) || subdomain(url);\nexport const path = path => isIpfs(path, pathPattern) || isIpns(path, pathPattern);\n/**\n * Returns `true` if the provided string or `Uint8Array`  is a valid `multihash`\n * or `false` otherwise.\n */\nexport { isMultihash as multihash };\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid multiaddr or `false` otherwise.\n */\nexport { isMultiaddr as multiaddr };\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid libp2p peer multiaddr (matching [`P2P`\n * format from `mafmt`](https://github.com/multiformats/js-mafmt#api)) or\n * `false` otherwise.\n */\nexport { isPeerMultiaddr as peerMultiaddr };\n/**\n * Returns `true` if the provided string, `Uint8Array` or [`CID`](https://github.com/multiformats/js-multiformats/#readme)\n * object represents a valid [CID](https://docs.ipfs.io/guides/concepts/cid/) or\n * `false` otherwise.\n */\nexport { isCID as cid };\n/**\n * Returns `true` if the provided string is a valid `CID` in Base32 encoding or\n * `false` otherwise.\n */\nexport const base32cid = cid => isCID(cid) && isBase32EncodedMultibase(cid);\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS path or `false`\n * otherwise.\n */\nexport const ipfsPath = path => isIpfs(path, pathPattern);\n/**\n * Returns `true` if the provided string is a valid IPNS path or `false`\n * otherwise.\n */\nexport const ipnsPath = path => isIpns(path, pathPattern);\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or path or\n * `false` otherwise.\n */\nexport const urlOrPath = x => url(x) || path(x);\n/**\n * Returns `true` if the provided string is a valid \"CID path\" (IPFS path\n * without `/ipfs/` prefix) or `false` otherwise.\n */\nexport const cidPath = path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern);","map":{"version":3,"names":["mafmt","multiaddr","URL","base32","base58btc","CID","Digest","toString","uint8ArrayToString","pathGatewayPattern","pathPattern","defaultProtocolMatch","defaultHashMath","subdomainGatewayPattern","subdomainIdMatch","subdomainProtocolMatch","fqdnWithTld","isMultihash","hash","formatted","convertToString","decode","isMultiaddr","input","Boolean","isBase32EncodedMultibase","cid","isString","parse","asCID","isCID","Uint8Array","isPeerMultiaddr","P2P","matches","isIpfs","pattern","protocolMatch","hashMatch","match","toLowerCase","isIpns","ipnsId","includes","replace","hostname","test","e","ipfsSubdomain","url","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","path","multihash","peerMultiaddr","base32cid","ipfsPath","ipnsPath","urlOrPath","x","cidPath"],"sources":["/Users/hprasad.sakhareicloud.com/Desktop/ipfs/StoreIPFSHash/node_modules/is-ipfs/src/index.ts"],"sourcesContent":["/**\n * @packageDocumentation\n *\n * A suite of util methods that provides efficient validation.\n *\n * Detection of IPFS Paths and identifiers in URLs is a two-stage process:\n *\n * 1. `pathPattern`/`pathGatewayPattern`/`subdomainGatewayPattern` regex is applied to quickly identify potential candidates\n * 2. proper CID validation is applied to remove false-positives\n *\n * @example\n *\n * ```TypeScript\n * import * as isIPFS from 'is-ipfs'\n *\n * isIPFS.multihash('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.multihash('noop') // false\n *\n * isIPFS.cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true (CIDv0)\n * isIPFS.cid('bafybeiasb5vpmaounyilfuxbd3lryvosl4yefqrfahsb2esg46q6tu6y5q') // true (CIDv1 in Base32)\n * isIPFS.cid('zdj7WWeQ43G6JJvLWQWZpyHuAMq6uYWRjkBXFad11vE2LHhQ7') // true (CIDv1 in Base58btc)\n * isIPFS.cid('noop') // false\n *\n * isIPFS.base32cid('bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va') // true\n * isIPFS.base32cid('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n *\n * isIPFS.url('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.url('https://ipfs.io/ipfs/QmbWqxBEKC3P8tqsKc98xmWNzrzDtRLMiMPL8wBuTGsMnR?filename=guardian.jpg') // true\n * isIPFS.url('https://ipfs.io/ipns/github.com') // true\n * isIPFS.url('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.url('http://en.wikipedia-on-ipfs.org.ipfs.localhost:8080') // true\n * isIPFS.url('https://github.com/ipfs/js-ipfs/blob/master/README.md') // false\n * isIPFS.url('https://google.com') // false\n *\n * isIPFS.path('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.path('/ipfs/QmbcBPAwCDxRMB1Qe7CRQmxdrTSkxKwM9y6rZw2FjGtbsb/?weird-filename=test.jpg') // true\n * isIPFS.path('/ipns/github.com') // true\n * isIPFS.path('/ipfs/js-ipfs/blob/master/README.md') // false\n *\n * isIPFS.urlOrPath('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('https://ipfs.io/ipns/github.com') // true\n * isIPFS.urlOrPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.urlOrPath('/ipns/github.com') // true\n * isIPFS.urlOrPath('https://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.urlOrPath('https://google.com') // false\n *\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsUrl('https://ipfs.io/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsUrl('https://ipfs.io/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsUrl('https://ipfs.io/ipns/github.com') // true\n *\n * isIPFS.ipfsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // true\n * isIPFS.ipfsPath('/ipfs/invalid-hash') // false\n *\n * isIPFS.ipnsPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.ipnsPath('/ipns/github.com') // true\n *\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/path/to/file') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/') // true\n * isIPFS.cidPath('QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o') // false\n * isIPFS.cidPath('/ipfs/QmYjtig7VJQ6XsnUjqqJvj7QaMcCAwtrgNdahSiFofrE7o/file') // false\n *\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.subdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.subdomain('http://www.bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // false\n * isIPFS.subdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.ipfs.dweb.link') // true\n * isIPFS.ipfsSubdomain('http://bafybeie5gq4jxvzmsym6hjlwxej4rwdoxt7wadqvmmwbqi7r27fclha2va.dweb.link') // false\n *\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.ipns.dweb.link') // true\n * isIPFS.ipnsSubdomain('http://bafybeiabc2xofh6tdi6vutusorpumwcikw3hf3st4ecjugo6j52f6xwc6q.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://QmcNioXSC1bfJj1dcFErhUfyjFzoX2HodkRccsFFVJJvg8.ipns.dweb.link') // false\n * isIPFS.ipnsSubdomain('http://en.wikipedia-on-ipfs.org.ipns.localhost:8080') // true (assuming DNSLink)\n * isIPFS.ipnsSubdomain('http://en-wikipedia--on--ipfs-org.ipns.localhost:8080') // true (assuming inlined DNSLink)\n * isIPFS.ipnsSubdomain('http://hostname-without-tld-.ipns.dweb.link') // false (not a CID, invalid DNS label)\n *\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234') // true\n * isIPFS.multiaddr('/ip4/127.0.0.1/udp/1234/http') // true\n * isIPFS.multiaddr('/ip6/::1/udp/1234') // true\n * isIPFS.multiaddr('ip6/::1/udp/1234') // false\n * isIPFS.multiaddr('/yoloinvalid/::1/udp/1234') // false\n *\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true\n * isIPFS.peerMultiaddr('/ipfs/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4') // true (legacy notation)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/tcp/1234/ws/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/p2p/QmcgpsyWgH8Y8ajJz1Cu72KnS5uo2Aa2LpzU7kinSoooo4/p2p-circuit/p2p/QmUjNmr8TgJCn1Ao7DvMy4cjoZU15b9bwSCBLE3vwXiwgj') // true\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io') // false (key missing, needs additional DNS lookup to tell if this is valid)\n * isIPFS.peerMultiaddr('/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN') // true (key present, ip and port can be resolved later)\n * isIPFS.peerMultiaddr('/ip4/127.0.0.1/udp/1234') // false (key missing)\n * ```\n */\n\nimport * as mafmt from '@multiformats/mafmt'\nimport { multiaddr } from '@multiformats/multiaddr'\nimport { URL } from 'iso-url'\nimport { base32 } from 'multiformats/bases/base32'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport const pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nexport const pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nexport const subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\nfunction isMultihash (hash: Uint8Array | string): boolean {\n  const formatted = convertToString(hash)\n\n  if (formatted === false) {\n    return false\n  }\n\n  try {\n    Digest.decode(base58btc.decode(`z${formatted}`))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isMultiaddr (input: string | Uint8Array | Multiaddr): input is Multiaddr {\n  try {\n    return Boolean(multiaddr(input))\n  } catch {\n    return false\n  }\n}\n\nfunction isBase32EncodedMultibase (hash: CID | string | Uint8Array): boolean {\n  try {\n    let cid: CID | null\n\n    if (isString(hash)) {\n      cid = CID.parse(hash)\n    } else {\n      cid = CID.asCID(hash)\n    }\n\n    if (cid == null) {\n      return false\n    }\n\n    base32.decode(cid.toString())\n  } catch {\n    return false\n  }\n\n  return true\n}\n\nfunction isCID (hash: CID | Uint8Array | string): hash is CID {\n  try {\n    if (isString(hash)) {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input: string | Uint8Array | Multiaddr): boolean {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath): boolean {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input: string | Uint8Array, pattern: RegExp | string, protocolMatch: number = defaultProtocolMatch, hashMatch: number = defaultHashMath): boolean {\n  const formatted = convertToString(input)\n  if (formatted === false) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (match == null) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId != null && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org → en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input: any): input is string {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input: Uint8Array | string): string | false {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS subdomain\n * (case-insensitive CIDv1) or `false` otherwise.\n */\nexport const ipfsSubdomain = (url: string | Uint8Array): boolean => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n\n/**\n * Returns `true` if the provided `url` string looks like a valid IPNS subdomain\n * (CIDv1 with `libp2p-key` multicodec or something that looks like a FQDN, for\n * example `en.wikipedia-on-ipfs.org.ipns.localhost:8080`) or `false` otherwise.\n *\n * **Note:** `ipnsSubdomain` method works in offline mode: it does not perform\n * actual IPNS record lookup over DHT or other content routing method. It may\n * return false-positives:\n *\n * - To ensure IPNS record  exists, make a call to `/api/v0/name/resolve?arg=<ipnsid>`\n * - To ensure DNSLink exists, make a call to `/api/v0/dns?arg=<fqdn>`\n */\nexport const ipnsSubdomain = (url: string | Uint8Array): boolean => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n\n/**\n * Returns `true` if the provided `url` string includes a valid IPFS, looks like\n * an IPNS/DNSLink subdomain or `false` otherwise.\n */\nexport const subdomain = (url: string | Uint8Array): boolean => ipfsSubdomain(url) || ipnsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPFS url or `false`\n * otherwise.\n */\nexport const ipfsUrl = (url: string | Uint8Array): boolean => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPNS url or `false`\n * otherwise.\n */\nexport const ipnsUrl = (url: string | Uint8Array): boolean => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or `false`\n * otherwise.\n */\nexport const url = (url: string | Uint8Array): boolean => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\nexport const path = (path: string | Uint8Array): boolean => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\n/**\n * Returns `true` if the provided string or `Uint8Array`  is a valid `multihash`\n * or `false` otherwise.\n */\nexport { isMultihash as multihash }\n\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid multiaddr or `false` otherwise.\n */\nexport { isMultiaddr as multiaddr }\n\n/**\n * Returns `true` if the provided `string`, [`Multiaddr`](https://github.com/multiformats/js-multiaddr)\n * or `Uint8Array` represents a valid libp2p peer multiaddr (matching [`P2P`\n * format from `mafmt`](https://github.com/multiformats/js-mafmt#api)) or\n * `false` otherwise.\n */\nexport { isPeerMultiaddr as peerMultiaddr }\n\n/**\n * Returns `true` if the provided string, `Uint8Array` or [`CID`](https://github.com/multiformats/js-multiformats/#readme)\n * object represents a valid [CID](https://docs.ipfs.io/guides/concepts/cid/) or\n * `false` otherwise.\n */\nexport { isCID as cid }\n\n/**\n * Returns `true` if the provided string is a valid `CID` in Base32 encoding or\n * `false` otherwise.\n */\nexport const base32cid = (cid: CID | string | Uint8Array): boolean => (isCID(cid) && isBase32EncodedMultibase(cid))\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS path or `false`\n * otherwise.\n */\nexport const ipfsPath = (path: string | Uint8Array): boolean => isIpfs(path, pathPattern)\n\n/**\n * Returns `true` if the provided string is a valid IPNS path or `false`\n * otherwise.\n */\nexport const ipnsPath = (path: string | Uint8Array): boolean => isIpns(path, pathPattern)\n\n/**\n * Returns `true` if the provided string is a valid IPFS or IPNS url or path or\n * `false` otherwise.\n */\nexport const urlOrPath = (x: string | Uint8Array): boolean => url(x) || path(x)\n\n/**\n * Returns `true` if the provided string is a valid \"CID path\" (IPFS path\n * without `/ipfs/` prefix) or `false` otherwise.\n */\nexport const cidPath = (path: string | Uint8Array | CID): boolean => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}