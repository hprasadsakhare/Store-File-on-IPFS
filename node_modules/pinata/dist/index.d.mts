type PinataConfig = {
    pinataJwt: string;
    pinataGateway?: string;
    pinataGatewayKey?: string;
    customHeaders?: Record<string, string>;
};
type AuthTestResponse = {
    message: string;
};
type PinResponse = {
    IpfsHash: string;
    PinSize: number;
    Timestamp: string;
    isDuplicate?: boolean;
};
type PinByCIDResponse = {
    id: string;
    ipfsHash: string;
    status: "prechecking" | "retrieving";
    name: string;
    updated?: boolean;
};
type FileObject = {
    name: string;
    size: number;
    type: string;
    lastModified: number;
    arrayBuffer: () => Promise<ArrayBuffer>;
};
type JsonBody = Record<string, unknown>;
type PinataMetadata = {
    name?: string;
    keyValues?: Record<string, string | number>;
};
type PinataMetadataUpdate = {
    cid: string;
    name?: string;
    keyValues?: Record<string, string | number>;
};
type UploadOptions = {
    metadata?: PinataMetadata;
    pinType?: "async" | "sync" | "cidOnly";
    keys?: string;
    groupId?: string;
    cidVersion?: 0 | 1;
};
type UploadCIDOptions = {
    metadata?: PinataMetadata;
    peerAddresses?: string[];
    keys?: string;
    groupId?: string;
};
type UnpinResponse = {
    hash: string;
    status: string;
};
type PinListItem = {
    id: string;
    ipfs_pin_hash: string;
    size: number;
    user_id: string;
    date_pinned: string;
    date_unpinned: string | null;
    metadata: {
        name: string | null;
        keyvalues: {
            [key: string]: any;
        } | null;
    };
    regions: {
        regionId: string;
        currentReplicationCount: number;
        desiredReplicationCount: number;
    }[];
    mime_type: string;
    number_of_files: number;
};
type PinListResponse = {
    rows: PinListItem[];
};
type PinListQuery = {
    cid?: string;
    pinStart?: string;
    pinEnd?: string;
    pinSizeMin?: number;
    pinSizeMax?: number;
    pageLimit?: number;
    pageOffset?: number;
    name?: string;
    groupId?: string;
    key?: string;
    value?: string | number;
    operator?: "gt" | "gte" | "lt" | "lte" | "ne" | "eq" | "between" | "notBetween" | "like" | "notLike" | "iLike" | "notILike" | "regexp" | "iRegexp";
};
type PinJobQuery = {
    sort?: "ASC" | "DSC";
    status?: "prechecking" | "retrieving" | "expired" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node";
    ipfs_pin_hash?: string;
    limit?: number;
    offset?: number;
};
type PinJobItem = {
    id: string;
    ipfs_pin_hash: string;
    date_queued: string;
    name: string;
    status: string;
    keyvalues: any;
    host_nodes: string[];
    pin_policy: {
        regions: {
            id: string;
            desiredReplicationCount: number;
        }[];
        version: number;
    };
};
type PinJobResponse = {
    rows: PinJobItem[];
};
type ContentType = "application/json" | "application/xml" | "text/plain" | "text/html" | "text/css" | "text/javascript" | "application/javascript" | "image/jpeg" | "image/png" | "image/gif" | "image/svg+xml" | "audio/mpeg" | "audio/ogg" | "video/mp4" | "application/pdf" | "application/octet-stream" | string | null;
type GetCIDResponse = {
    data?: JSON | string | Blob | null;
    contentType: ContentType;
};
type UserPinnedDataResponse = {
    pin_count: number;
    pin_size_total: number;
    pin_size_with_replications_total: number;
};
type KeyPermissions = {
    admin?: boolean;
    endpoints?: Endpoints;
};
type Endpoints = {
    data?: DataEndponts;
    pinning?: PinningEndpoints;
};
type DataEndponts = {
    pinList?: boolean;
    userPinnedDataTotal?: boolean;
};
type PinningEndpoints = {
    hashMetadata?: boolean;
    hashPinPolicy?: boolean;
    pinByHash?: boolean;
    pinFileToIPFS?: boolean;
    pinJSONToIPFS?: boolean;
    pinJobs?: boolean;
    unpin?: boolean;
    userPinPolicy?: boolean;
};
type KeyOptions = {
    keyName: string;
    permissions: KeyPermissions;
    maxUses?: number;
};
type KeyResponse = {
    JWT: string;
    pinata_api_key: string;
    pinata_api_secret: string;
};
type KeyListQuery = {
    revoked?: boolean;
    limitedUse?: boolean;
    exhausted?: boolean;
    name?: string;
    offset?: number;
};
type KeyListItem = {
    id: string;
    name: string;
    key: string;
    secret: string;
    max_uses: number;
    uses: number;
    user_id: string;
    scopes: KeyScopes;
    revoked: boolean;
    createdAt: string;
    updatedAt: string;
};
type KeyScopes = {
    endpoints: {
        pinning: {
            pinFileToIPFS: boolean;
            pinJSONToIPFS: boolean;
        };
    };
    admin: boolean;
};
type KeyListResponse = {
    keys: KeyListItem[];
    count: number;
};
type RevokeKeyResponse = {
    key: string;
    status: string;
};
type GroupOptions = {
    name: string;
};
type UpdateGroupOptions = {
    name: string;
    groupId: string;
};
type GetGroupOptions = {
    groupId: string;
};
type GroupResponseItem = {
    id: string;
    user_id: string;
    name: string;
    updatedAt: string;
    createdAt: string;
};
type GroupQueryOptions = {
    nameContains?: string;
    offset?: number;
    limit?: number;
};
type GroupCIDOptions = {
    groupId: string;
    cids: string[];
};
type SignatureOptions = {
    cid: string;
    signature: string;
};
type SignatureResponse = {
    cid: string;
    signature: string;
};

declare class PinataSDK {
    config: PinataConfig | undefined;
    upload: Upload;
    gateways: Gateways;
    usage: Usage;
    keys: Keys;
    groups: Groups;
    signatures: Signatures;
    constructor(config?: PinataConfig);
    testAuthentication(): Promise<AuthTestResponse>;
    unpin(files: string[]): Promise<UnpinResponse[]>;
    listFiles(): FilterFiles;
    updateMetadata(options: PinataMetadataUpdate): Promise<string>;
    pinJobs(): FilterPinJobs;
}
declare class UploadBuilder<T> {
    private config;
    private uploadFunction;
    private args;
    private metadata;
    private keys;
    private peerAddresses;
    private version;
    private groupId;
    constructor(config: PinataConfig | undefined, uploadFunction: (config: PinataConfig | undefined, ...args: any[]) => Promise<T>, ...args: any[]);
    addMetadata(metadata: PinataMetadata): UploadBuilder<T>;
    key(jwt: string): UploadBuilder<T>;
    cidVersion(v: 0 | 1): UploadBuilder<T>;
    group(groupId: string): UploadBuilder<T>;
    peerAddress(peerAddresses: string[]): UploadBuilder<T>;
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null | undefined, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null | undefined): Promise<TResult1 | TResult2>;
}
declare class Upload {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    file(file: FileObject, options?: UploadOptions): UploadBuilder<PinResponse>;
    fileArray(files: FileObject[], options?: UploadOptions): UploadBuilder<PinResponse>;
    base64(base64String: string, options?: UploadOptions): UploadBuilder<PinResponse>;
    url(url: string, options?: UploadOptions): UploadBuilder<PinResponse>;
    json(data: object, options?: UploadOptions): UploadBuilder<PinResponse>;
    cid(cid: string, options?: UploadCIDOptions): UploadBuilder<PinByCIDResponse>;
}
declare class FilterFiles {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    cid(cid: string): FilterFiles;
    pinStart(date: string): FilterFiles;
    pinEnd(date: string): FilterFiles;
    pinSizeMin(size: number): FilterFiles;
    pinSizeMax(size: number): FilterFiles;
    pageLimit(limit: number): FilterFiles;
    pageOffset(offset: number): FilterFiles;
    name(name: string): FilterFiles;
    group(groupId: string): FilterFiles;
    keyValue(key: string, value: string | number, operator?: PinListQuery["operator"]): FilterFiles;
    then(onfulfilled?: ((value: PinListItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<PinListItem, void, unknown>;
    all(): Promise<PinListItem[]>;
}
declare class Gateways {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    get(cid: string): Promise<GetCIDResponse>;
    convert(url: string): Promise<string>;
}
declare class FilterPinJobs {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    cid(cid: string): FilterPinJobs;
    status(status: "prechecking" | "retrieving" | "expired" | "over_free_limit" | "over_max_size" | "invalid_object" | "bad_host_node"): FilterPinJobs;
    pageLimit(limit: number): FilterPinJobs;
    pageOffset(offset: number): FilterPinJobs;
    sort(sort: "ASC" | "DSC"): FilterPinJobs;
    then(onfulfilled?: ((value: PinJobItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<PinJobItem, void, unknown>;
    all(): Promise<PinJobItem[]>;
}
declare class Usage {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    pinnedFileCount(): Promise<number>;
    totalStorageSize(): Promise<number>;
}
declare class Keys {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    create(options: KeyOptions): Promise<KeyResponse>;
    list(): FilterKeys;
    revoke(keys: string[]): Promise<RevokeKeyResponse[]>;
}
declare class FilterKeys {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterKeys;
    revoked(revoked: boolean): FilterKeys;
    limitedUse(limitedUse: boolean): FilterKeys;
    exhausted(exhausted: boolean): FilterKeys;
    name(name: string): FilterKeys;
    then(onfulfilled?: ((value: KeyListItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<KeyListItem, void, unknown>;
    all(): Promise<KeyListItem[]>;
}
declare class Groups {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    create(options: GroupOptions): Promise<GroupResponseItem>;
    list(): FilterGroups;
    get(options: GetGroupOptions): Promise<GroupResponseItem>;
    addCids(options: GroupCIDOptions): Promise<string>;
    removeCids(options: GroupCIDOptions): Promise<string>;
    update(options: UpdateGroupOptions): Promise<GroupResponseItem>;
    delete(options: GetGroupOptions): Promise<string>;
}
declare class FilterGroups {
    private config;
    private query;
    private requestCount;
    private lastRequestTime;
    private readonly MAX_REQUESTS_PER_MINUTE;
    private readonly MINUTE_IN_MS;
    constructor(config: PinataConfig | undefined);
    offset(offset: number): FilterGroups;
    name(nameContains: string): FilterGroups;
    limit(limit: number): FilterGroups;
    then(onfulfilled?: ((value: GroupResponseItem[]) => any) | null): Promise<any>;
    private rateLimit;
    [Symbol.asyncIterator](): AsyncGenerator<GroupResponseItem, void, unknown>;
    all(): Promise<GroupResponseItem[]>;
}
declare class Signatures {
    config: PinataConfig | undefined;
    constructor(config?: PinataConfig);
    add(options: SignatureOptions): Promise<SignatureResponse>;
    get(cid: string): Promise<SignatureResponse>;
    delete(cid: string): Promise<string>;
}

export { type AuthTestResponse, type ContentType, type DataEndponts, type Endpoints, type FileObject, type GetCIDResponse, type GetGroupOptions, type GroupCIDOptions, type GroupOptions, type GroupQueryOptions, type GroupResponseItem, type JsonBody, type KeyListItem, type KeyListQuery, type KeyListResponse, type KeyOptions, type KeyPermissions, type KeyResponse, type PinByCIDResponse, type PinJobItem, type PinJobQuery, type PinJobResponse, type PinListItem, type PinListQuery, type PinListResponse, type PinResponse, type PinataConfig, type PinataMetadata, type PinataMetadataUpdate, PinataSDK, type PinningEndpoints, type RevokeKeyResponse, type SignatureOptions, type SignatureResponse, type UnpinResponse, type UpdateGroupOptions, type UploadCIDOptions, type UploadOptions, type UserPinnedDataResponse };
