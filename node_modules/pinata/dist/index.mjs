// src/utils/custom-errors.ts
var PinataError = class extends Error {
  constructor(message, statusCode, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
    this.name = "PinataError";
  }
};
var NetworkError = class extends PinataError {
  constructor(message, statusCode, details) {
    super(message, statusCode, details);
    this.name = "NetworkError";
  }
};
var AuthenticationError = class extends PinataError {
  constructor(message, statusCode, details) {
    super(message, statusCode, details);
    this.name = "AuthenticationError";
  }
};
var ValidationError = class extends PinataError {
  constructor(message, details) {
    super(message, void 0, details);
    this.name = "ValidationError";
  }
};

// src/core/authentication/testAuthentication.ts
var testAuthentication = async (config) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/testAuthentication";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/data/testAuthentication",
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(
        `Error processing authentication: ${error.message}`
      );
    }
    throw new PinataError(
      "An unknown error occurred while testing authentication"
    );
  }
};

// src/core/pinning/file.ts
var uploadFile = async (config, file, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const jwt = options?.keys || config.pinataJwt;
  const data = new FormData();
  data.append("file", file, file.name);
  data.append(
    "pinataOptions",
    JSON.stringify({
      cidVersion: options?.cidVersion,
      groupId: options?.groupId
    })
  );
  data.append(
    "pinataMetadata",
    JSON.stringify({
      name: options?.metadata ? options.metadata.name : file.name,
      keyvalues: options?.metadata?.keyValues
    })
  );
  const headers = {
    Authorization: `Bearer ${jwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/file";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error uploading file: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while uploading the file");
  }
};

// src/core/pinning/fileArray.ts
var uploadFileArray = async (config, files, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const folder = options?.metadata?.name ?? "folder_from_sdk";
  const data = new FormData();
  for (const file of Array.from(files)) {
    data.append("file", file, `${folder}/${file.name}`);
  }
  data.append(
    "pinataMetadata",
    JSON.stringify({
      name: folder,
      keyvalues: options?.metadata?.keyValues
    })
  );
  data.append(
    "pinataOptions",
    JSON.stringify({
      cidVersion: options?.cidVersion,
      groupId: options?.groupId
    })
  );
  const headers = {
    Authorization: `Bearer ${jwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/fileArray";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing fileArray: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while uploading an array of files"
    );
  }
};

// src/core/pinning/base64.ts
var uploadBase64 = async (config, base64String, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const name = options?.metadata?.name ? options?.metadata?.name : "base64 string";
  const buffer = Buffer.from(base64String, "base64");
  const blob = new Blob([buffer]);
  const data = new FormData();
  data.append("file", blob, name);
  data.append(
    "pinataOptions",
    JSON.stringify({
      cidVersion: options?.cidVersion,
      groupId: options?.groupId
    })
  );
  data.append(
    "pinataMetadata",
    JSON.stringify({
      name,
      keyvalues: options?.metadata?.keyValues
    })
  );
  const headers = {
    Authorization: `Bearer ${jwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/base64";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing base64: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while trying to upload base64"
    );
  }
};

// src/core/pinning/url.ts
var uploadUrl = async (config, url, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const data = new FormData();
  const stream = await fetch(url);
  if (!stream.ok) {
    const errorData = await stream.json();
    throw new NetworkError(
      `HTTP error! status: ${stream.status}`,
      stream.status,
      errorData
    );
  }
  const arrayBuffer = await stream.arrayBuffer();
  const blob = new Blob([arrayBuffer]);
  const name = options?.metadata?.name ?? "url_upload";
  const file = new File([blob], name);
  data.append("file", file, name);
  data.append(
    "pinataOptions",
    JSON.stringify({
      cidVersion: options?.cidVersion,
      groupId: options?.groupId
    })
  );
  data.append(
    "pinataMetadata",
    JSON.stringify({
      name,
      keyvalues: options?.metadata?.keyValues
    })
  );
  const headers = {
    Authorization: `Bearer ${jwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/url";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/pinning/pinFileToIPFS",
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing url: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while uploading by url");
  }
};

// src/core/pinning/json.ts
var uploadJson = async (config, jsonData, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const data = JSON.stringify({
    pinataContent: jsonData,
    pinataOptions: {
      cidVersion: options?.cidVersion,
      groupId: options?.groupId
    },
    pinataMetadata: {
      name: options?.metadata ? options.metadata.name : "json",
      keyvalues: options?.metadata?.keyValues
    }
  });
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${jwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/json";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/pinning/pinJSONToIPFS",
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing json: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while uploading json");
  }
};

// src/core/pinning/cid.ts
var uploadCid = async (config, cid, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const jwt = options?.keys || config?.pinataJwt;
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${jwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/cid";
  const data = JSON.stringify({
    hashToPin: cid,
    pinataMetadata: {
      name: options?.metadata ? options?.metadata?.name : cid,
      keyvalues: options?.metadata?.keyValues
    },
    pinataOptions: {
      hostNodes: options?.peerAddresses ? options.peerAddresses : "",
      groupId: options?.groupId
    }
  });
  try {
    const request = await fetch("https://api.pinata.cloud/pinning/pinByHash", {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing cid: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while pinning by CID");
  }
};

// src/core/pinning/unpin.ts
var wait = (milliseconds) => {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
};
var unpinFile = async (config, files) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const responses = [];
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/unpin";
  for (const hash of files) {
    try {
      const response = await fetch(
        `https://api.pinata.cloud/pinning/unpin/${hash}`,
        {
          method: "DELETE",
          headers
        }
      );
      await wait(300);
      if (!response.ok) {
        const errorData = await response.json();
        if (response.status === 401) {
          throw new AuthenticationError(
            "Authentication failed",
            response.status,
            errorData
          );
        }
        throw new NetworkError(
          `HTTP error! status: ${response.status}`,
          response.status,
          errorData
        );
      }
      const result = await response.text();
      responses.push({
        hash,
        status: result
      });
    } catch (error) {
      let errorMessage;
      if (error instanceof PinataError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Error unpinning file ${hash}: ${error.message}`;
      } else {
        errorMessage = `An unknown error occurred while unpinning file ${hash}`;
      }
      responses.push({
        hash,
        status: errorMessage
      });
    }
  }
  return responses;
};

// src/core/data/listFiles.ts
var listFiles = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const params = new URLSearchParams({
    includesCount: "false"
  });
  if (options) {
    const {
      cid,
      pinStart,
      pinEnd,
      pinSizeMin,
      pinSizeMax,
      pageLimit,
      pageOffset,
      name,
      key,
      value,
      operator,
      groupId
    } = options;
    if (cid)
      params.append("cid", cid);
    if (pinStart)
      params.append("pinStart", pinStart);
    if (pinEnd)
      params.append("pinEnd", pinEnd);
    if (pinSizeMin)
      params.append("pinSizeMin", pinSizeMin.toString());
    if (pinSizeMax)
      params.append("pinSizeMax", pinSizeMax.toString());
    if (pageLimit)
      params.append("pageLimit", pageLimit.toString());
    if (pageOffset)
      params.append("pageOffset", pageOffset.toString());
    if (groupId)
      params.append("groupId", groupId);
    if (name)
      params.append("metadata[name]", name);
    if (key && value) {
      const keyValueParam = JSON.stringify({
        [key]: { value, op: operator || "eq" }
      });
      params.append("metadata[keyvalues]", keyValueParam);
    }
  }
  const url = `https://api.pinata.cloud/data/pinList?status=pinned&${params.toString()}`;
  try {
    const headers = {
      Authorization: `Bearer ${config?.pinataJwt}`
    };
    if (config.customHeaders) {
      Object.assign(headers, config.customHeaders);
    }
    headers["Source"] = headers["Source"] || "sdk/listFiles";
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.rows;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing list files: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while listing files");
  }
};

// src/core/data/updateMetadata.ts
var updateMetadata = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const data = {
    ipfsPinHash: options.cid,
    name: options.name,
    keyvalues: options.keyValues
  };
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/updateMetadata";
  try {
    const request = await fetch(
      "https://api.pinata.cloud/pinning/hashMetadata",
      {
        method: "PUT",
        headers,
        body: JSON.stringify(data)
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.text();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(
        `Error processing updateMetadata: ${error.message}`
      );
    }
    throw new PinataError("An unknown error occurred while updating metadata");
  }
};

// src/utils/gateway-tools.ts
var isIPFSModule;
async function getIsIPFS() {
  if (!isIPFSModule) {
    isIPFSModule = await import("is-ipfs");
  }
  return isIPFSModule;
}
async function containsCID(input) {
  if (typeof input !== "string") {
    throw new Error("Input is not a string");
  }
  const isIPFS = await getIsIPFS();
  const startsWithCID = (str) => {
    const parts = str.split("/");
    return isIPFS.cid(parts[0]) ? parts[0] : null;
  };
  const directCID = startsWithCID(input);
  if (directCID) {
    return {
      containsCid: true,
      cid: directCID
    };
  }
  let url;
  try {
    url = new URL(input);
  } catch (error) {
    const parts = input.split(/\/|\?/);
    for (const part of parts) {
      const cid = startsWithCID(part);
      if (cid) {
        return {
          containsCid: true,
          cid
        };
      }
    }
    return {
      containsCid: false,
      cid: null
    };
  }
  const subdomains = url.hostname.split(".");
  for (const subdomain of subdomains) {
    if (isIPFS.cid(subdomain)) {
      return {
        containsCid: true,
        cid: subdomain
      };
    }
  }
  const pathParts = url.pathname.split("/");
  for (const part of pathParts) {
    const cid = startsWithCID(part);
    if (cid) {
      return {
        containsCid: true,
        cid
      };
    }
  }
  return {
    containsCid: false,
    cid: null
  };
}
async function convertToDesiredGateway(sourceUrl, desiredGatewayPrefix) {
  const results = await containsCID(sourceUrl);
  if (results.containsCid !== true) {
    throw new Error("url does not contain CID");
  }
  if (!sourceUrl.startsWith("https") && !sourceUrl.startsWith("ipfs://")) {
    return `${desiredGatewayPrefix}/ipfs/${sourceUrl}`;
  }
  const urlObj = new URL(sourceUrl);
  const path = urlObj.pathname + urlObj.search + urlObj.hash;
  if (sourceUrl.startsWith(`ipfs://${results.cid}`)) {
    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;
  }
  if (sourceUrl.includes(`/ipfs/${results.cid}`)) {
    return `${desiredGatewayPrefix}${path}`;
  }
  if (sourceUrl.includes(`/ipns/${results.cid}`)) {
    return `${desiredGatewayPrefix}${path}`;
  }
  if (urlObj.hostname.includes(results.cid)) {
    return `${desiredGatewayPrefix}/ipfs/${results.cid}${path}`;
  }
  throw new Error(
    "unsupported URL pattern, please submit a github issue with the URL utilized"
  );
}

// src/core/gateway/getCid.ts
var getCid = async (config, cid) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  let data;
  let newUrl;
  newUrl = await convertToDesiredGateway(cid, config?.pinataGateway);
  if (config?.pinataGatewayKey) {
    newUrl = `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;
  }
  try {
    const request = await fetch(newUrl, {
      method: "GET",
      headers: {
        Source: "sdk/getCid"
      }
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const contentType = request.headers.get("content-type");
    if (contentType?.includes("application/json")) {
      data = await request.json();
    } else if (contentType?.includes("text/")) {
      data = await request.text();
    } else {
      data = await request.blob();
    }
    const res = {
      data,
      contentType
    };
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing getCid: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while getting CID contents"
    );
  }
};

// src/core/gateway/convertIPFSUrl.ts
var convertIPFSUrl = async (config, url) => {
  let newUrl;
  newUrl = await convertToDesiredGateway(url, config?.pinataGateway);
  if (config?.pinataGatewayKey) {
    `${newUrl}?pinataGatewayToken=${config?.pinataGatewayKey}`;
  }
  return newUrl;
};

// src/core/data/pinJobs.ts
var pinJobs = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const params = new URLSearchParams({
    includesCount: "false"
  });
  if (options) {
    const { ipfs_pin_hash: cid, status, sort, limit, offset } = options;
    if (cid)
      params.append("ipfs_pin_hash", cid.toString());
    if (status)
      params.append("status", status.toString());
    if (sort)
      params.append("sort", sort.toString());
    if (limit)
      params.append("limit", limit.toString());
    if (offset)
      params.append("offset", offset.toString());
  }
  const url = `https://api.pinata.cloud/pinning/pinJobs?${params.toString()}`;
  const headers = {
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/pinJobs";
  try {
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.rows;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing pinJobs: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while listing pin jobs");
  }
};

// src/core/data/pinnedFileUsage.ts
var pinnedFileCount = async (config) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const url = "https://api.pinata.cloud/data/userPinnedDataTotal";
  const headers = {
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/pinnedFileUsage";
  try {
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.pin_count;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(
        `Error processing pinnedFileUsage: ${error.message}`
      );
    }
    throw new PinataError(
      "An unknown error occurred while getting pinned file usage"
    );
  }
};

// src/core/data/totalStorageUsage.ts
var totalStorageUsage = async (config) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const url = "https://api.pinata.cloud/data/userPinnedDataTotal";
  const headers = {
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/totalStorageUsage";
  try {
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.pin_size_total;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(
        `Error processing totalStorageUsage: ${error.message}`
      );
    }
    throw new PinataError(
      "An unknown error occurred while getting total storage usage"
    );
  }
};

// src/core/keys/createKey.ts
var createKey = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/createKey";
  const data = JSON.stringify(options);
  try {
    const request = await fetch("https://api.pinata.cloud/v3/pinata/keys", {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing createKey: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while creating API key");
  }
};

// src/core/keys/listKeys.ts
var listKeys = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/listKeys";
  const params = new URLSearchParams();
  if (options) {
    const { offset, name, revoked, limitedUse, exhausted } = options;
    if (offset)
      params.append("offset", offset.toString());
    if (revoked !== void 0)
      params.append("revoked", revoked.toString());
    if (limitedUse !== void 0)
      params.append("limitedUse", limitedUse.toString());
    if (exhausted !== void 0)
      params.append("exhausted", exhausted.toString());
    if (name)
      params.append("name", name);
  }
  const url = `https://api.pinata.cloud/v3/pinata/keys?${params.toString()}`;
  try {
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.keys;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing listKeys: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while listing API keys");
  }
};

// src/core/keys/revokeKeys.ts
var wait2 = (milliseconds) => {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
};
var revokeKeys = async (config, keys) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/revokeKeys";
  const responses = [];
  for (const key of keys) {
    try {
      const request = await fetch(
        `https://api.pinata.cloud/v3/pinata/keys/${key}`,
        {
          method: "PUT",
          headers
        }
      );
      await wait2(300);
      if (!request.ok) {
        const errorData = await request.json();
        if (request.status === 401) {
          throw new AuthenticationError(
            "Authentication failed",
            request.status,
            errorData
          );
        }
        throw new NetworkError(
          `HTTP error! status: ${request.status}`,
          request.status,
          errorData
        );
      }
      const result = await request.json();
      responses.push({
        key,
        status: result
      });
    } catch (error) {
      let errorMessage;
      if (error instanceof PinataError) {
        errorMessage = error.message;
      } else if (error instanceof Error) {
        errorMessage = `Error revoking key ${key}: ${error.message}`;
      } else {
        errorMessage = `An unknown error occurred while revoking key ${key}`;
      }
      responses.push({
        key,
        status: errorMessage
      });
    }
  }
  return responses;
};

// src/core/groups/createGroup.ts
var createGroup = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const data = JSON.stringify(options);
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/createGroup";
  try {
    const request = await fetch("https://api.pinata.cloud/groups", {
      method: "POST",
      headers,
      body: data
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing createGroup: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while creating a group");
  }
};

// src/core/groups/listGroups.ts
var listGroups = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/listGroups";
  const params = new URLSearchParams();
  if (options) {
    const { offset, nameContains, limit } = options;
    if (offset)
      params.append("offset", offset.toString());
    if (nameContains !== void 0)
      params.append("nameContains", nameContains.toString());
    if (limit !== void 0)
      params.append("limit", limit.toString());
  }
  const url = `https://api.pinata.cloud/groups?${params.toString()}`;
  try {
    const request = await fetch(url, {
      method: "GET",
      headers
    });
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing listGroups: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while listing groups");
  }
};

// src/core/groups/getGroup.ts
var getGroup = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/getGroup";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/groups/${options.groupId}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing getGroup: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while getting info for a group"
    );
  }
};

// src/core/groups/addToGroup.ts
var addToGroup = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const data = JSON.stringify({
    cids: options.cids
  });
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/addToGroup";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/groups/${options.groupId}/cids`,
      {
        method: "PUT",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.text();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing addToGroup: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while adding CIDs to group"
    );
  }
};

// src/core/groups/updateGroup.ts
var updateGroup = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const data = JSON.stringify({
    name: options.name
  });
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/updateGroup";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/groups/${options.groupId}`,
      {
        method: "PUT",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing updateGroup: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while updating group");
  }
};

// src/core/groups/removeFromGroup.ts
var removeFromGroup = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/removeFromGroup";
  const data = JSON.stringify({
    cids: options.cids
  });
  try {
    const request = await fetch(
      `https://api.pinata.cloud/groups/${options.groupId}/cids`,
      {
        method: "DELETE",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.text();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(
        `Error processing removeFromGroup: ${error.message}`
      );
    }
    throw new PinataError(
      "An unknown error occurred while removing CIDs from a group"
    );
  }
};

// src/core/groups/deleteGroup.ts
var deleteGroup = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/deleteGroup";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/groups/${options.groupId}`,
      {
        method: "DELETE",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.text();
    return res;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing deleteGroup: ${error.message}`);
    }
    throw new PinataError("An unknown error occurred while deleting a group");
  }
};

// src/core/signatures/addSignature.ts
var addSignature = async (config, options) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const data = JSON.stringify({
    signature: options.signature
  });
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/addSignature";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/v3/ipfs/signature/${options.cid}`,
      {
        method: "POST",
        headers,
        body: data
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      if (request.status === 403) {
        throw new PinataError(
          "Unauthorized signing, you must be the original owner of the file and it must not have a signature",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.data;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing addSignature: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while adding signature to CID"
    );
  }
};

// src/core/signatures/getSignature.ts
var getSignature = async (config, cid) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/getSignature";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/v3/ipfs/signature/${cid}`,
      {
        method: "GET",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    const res = await request.json();
    return res.data;
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing getSignature: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while fetching signature for CID"
    );
  }
};

// src/core/signatures/removeSignature.ts
var removeSignature = async (config, cid) => {
  if (!config || !config.pinataJwt) {
    throw new ValidationError("Pinata configuration or JWT is missing");
  }
  const headers = {
    "Content-Type": "application/json",
    Authorization: `Bearer ${config?.pinataJwt}`
  };
  if (config.customHeaders) {
    Object.assign(headers, config.customHeaders);
  }
  headers["Source"] = headers["Source"] || "sdk/removeSignature";
  try {
    const request = await fetch(
      `https://api.pinata.cloud/v3/ipfs/signature/${cid}`,
      {
        method: "DELETE",
        headers
      }
    );
    if (!request.ok) {
      const errorData = await request.json();
      if (request.status === 401) {
        throw new AuthenticationError(
          "Authentication failed",
          request.status,
          errorData
        );
      }
      throw new NetworkError(
        `HTTP error! status: ${request.status}`,
        request.status,
        errorData
      );
    }
    return "OK";
  } catch (error) {
    if (error instanceof PinataError) {
      throw error;
    }
    if (error instanceof Error) {
      throw new PinataError(`Error processing addSignature: ${error.message}`);
    }
    throw new PinataError(
      "An unknown error occurred while adding signature to CID"
    );
  }
};

// src/core/pinataSDK.ts
var formatConfig = (config) => {
  let gateway = config?.pinataGateway;
  if (config && gateway) {
    if (gateway && !gateway.startsWith("https://")) {
      gateway = `https://${gateway}`;
    }
    config.pinataGateway = gateway;
  }
  return config;
};
var PinataSDK = class {
  constructor(config) {
    this.config = formatConfig(config);
    this.upload = new Upload(this.config);
    this.gateways = new Gateways(this.config);
    this.usage = new Usage(this.config);
    this.keys = new Keys(this.config);
    this.groups = new Groups(this.config);
    this.signatures = new Signatures(this.config);
  }
  testAuthentication() {
    return testAuthentication(this.config);
  }
  unpin(files) {
    return unpinFile(this.config, files);
  }
  listFiles() {
    return new FilterFiles(this.config);
  }
  updateMetadata(options) {
    return updateMetadata(this.config, options);
  }
  pinJobs() {
    return new FilterPinJobs(this.config);
  }
};
var UploadBuilder = class {
  constructor(config, uploadFunction, ...args) {
    this.config = config;
    this.uploadFunction = uploadFunction;
    this.args = args;
    this.version = 1;
  }
  addMetadata(metadata) {
    this.metadata = metadata;
    return this;
  }
  key(jwt) {
    this.keys = jwt;
    return this;
  }
  cidVersion(v) {
    this.version = v;
    return this;
  }
  group(groupId) {
    this.groupId = groupId;
    return this;
  }
  peerAddress(peerAddresses) {
    this.peerAddresses = peerAddresses;
    return this;
  }
  then(onfulfilled, onrejected) {
    const options = this.args[this.args.length - 1] || {};
    if (this.metadata) {
      options.metadata = this.metadata;
    }
    if (this.keys) {
      options.keys = this.keys;
    }
    if (this.groupId) {
      options.groupId = this.groupId;
    }
    if (this.version) {
      options.cidVersion = this.version;
    }
    if (this.peerAddresses && "peerAddresses" in options) {
      options.peerAddresses = this.peerAddresses;
    }
    this.args[this.args.length - 1] = options;
    return this.uploadFunction(this.config, ...this.args).then(
      onfulfilled,
      onrejected
    );
  }
};
var Upload = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  file(file, options) {
    return new UploadBuilder(this.config, uploadFile, file, options);
  }
  fileArray(files, options) {
    return new UploadBuilder(this.config, uploadFileArray, files, options);
  }
  base64(base64String, options) {
    return new UploadBuilder(this.config, uploadBase64, base64String, options);
  }
  url(url, options) {
    return new UploadBuilder(this.config, uploadUrl, url, options);
  }
  json(data, options) {
    return new UploadBuilder(this.config, uploadJson, data, options);
  }
  cid(cid, options) {
    return new UploadBuilder(this.config, uploadCid, cid, options);
  }
};
var FilterFiles = class {
  constructor(config) {
    this.query = {};
    // rate limit vars
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.MAX_REQUESTS_PER_MINUTE = 30;
    this.MINUTE_IN_MS = 6e4;
    this.config = config;
  }
  cid(cid) {
    this.query.cid = cid;
    return this;
  }
  pinStart(date) {
    this.query.pinStart = date;
    return this;
  }
  pinEnd(date) {
    this.query.pinEnd = date;
    return this;
  }
  pinSizeMin(size) {
    this.query.pinSizeMin = size;
    return this;
  }
  pinSizeMax(size) {
    this.query.pinSizeMax = size;
    return this;
  }
  pageLimit(limit) {
    this.query.pageLimit = limit;
    return this;
  }
  pageOffset(offset) {
    this.query.pageOffset = offset;
    return this;
  }
  name(name) {
    this.query.name = name;
    return this;
  }
  group(groupId) {
    this.query.groupId = groupId;
    return this;
  }
  keyValue(key, value, operator) {
    this.query.key = key;
    this.query.value = value;
    if (operator) {
      this.query.operator = operator;
    }
    return this;
  }
  then(onfulfilled) {
    return listFiles(this.config, this.query).then(onfulfilled);
  }
  // rate limit, hopefully temporary?
  async rateLimit() {
    this.requestCount++;
    const now = Date.now();
    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
      const timePassedSinceLastRequest = now - this.lastRequestTime;
      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
        await new Promise((resolve) => setTimeout(resolve, delayTime));
      }
      this.requestCount = 0;
    }
    this.lastRequestTime = Date.now();
  }
  async *[Symbol.asyncIterator]() {
    let hasMore = true;
    let offset = 0;
    const limit = this.query.pageLimit || 10;
    while (hasMore) {
      await this.rateLimit();
      this.query.pageOffset = offset;
      this.query.pageLimit = limit;
      const items = await listFiles(this.config, this.query);
      for (const item of items) {
        yield item;
      }
      if (items.length === 0) {
        hasMore = false;
      } else {
        offset += items.length;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};
var Gateways = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  get(cid) {
    return getCid(this.config, cid);
  }
  convert(url) {
    return convertIPFSUrl(this.config, url);
  }
};
var FilterPinJobs = class {
  constructor(config) {
    this.query = {};
    // rate limit vars
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.MAX_REQUESTS_PER_MINUTE = 30;
    this.MINUTE_IN_MS = 6e4;
    this.config = config;
  }
  cid(cid) {
    this.query.ipfs_pin_hash = cid;
    return this;
  }
  status(status) {
    this.query.status = status;
    return this;
  }
  pageLimit(limit) {
    this.query.limit = limit;
    return this;
  }
  pageOffset(offset) {
    this.query.offset = offset;
    return this;
  }
  sort(sort) {
    this.query.sort = sort;
    return this;
  }
  then(onfulfilled) {
    return pinJobs(this.config, this.query).then(onfulfilled);
  }
  // rate limit, hopefully temporary?
  async rateLimit() {
    this.requestCount++;
    const now = Date.now();
    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
      const timePassedSinceLastRequest = now - this.lastRequestTime;
      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
        await new Promise((resolve) => setTimeout(resolve, delayTime));
      }
      this.requestCount = 0;
    }
    this.lastRequestTime = Date.now();
  }
  async *[Symbol.asyncIterator]() {
    let hasMore = true;
    let offset = 0;
    const limit = this.query.limit || 10;
    while (hasMore) {
      await this.rateLimit();
      this.query.offset = offset;
      this.query.limit = limit;
      const items = await pinJobs(this.config, this.query);
      for (const item of items) {
        yield item;
      }
      if (items.length === 0) {
        hasMore = false;
      } else {
        offset += items.length;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};
var Usage = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  pinnedFileCount() {
    return pinnedFileCount(this.config);
  }
  totalStorageSize() {
    return totalStorageUsage(this.config);
  }
};
var Keys = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  create(options) {
    return createKey(this.config, options);
  }
  list() {
    return new FilterKeys(this.config);
  }
  revoke(keys) {
    return revokeKeys(this.config, keys);
  }
};
var FilterKeys = class {
  constructor(config) {
    this.query = {};
    // rate limit vars
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.MAX_REQUESTS_PER_MINUTE = 30;
    this.MINUTE_IN_MS = 6e4;
    this.config = config;
  }
  offset(offset) {
    this.query.offset = offset;
    return this;
  }
  revoked(revoked) {
    this.query.revoked = revoked;
    return this;
  }
  limitedUse(limitedUse) {
    this.query.limitedUse = limitedUse;
    return this;
  }
  exhausted(exhausted) {
    this.query.exhausted = exhausted;
    return this;
  }
  name(name) {
    this.query.name = name;
    return this;
  }
  then(onfulfilled) {
    return listKeys(this.config, this.query).then(onfulfilled);
  }
  // rate limit, hopefully temporary?
  async rateLimit() {
    this.requestCount++;
    const now = Date.now();
    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
      const timePassedSinceLastRequest = now - this.lastRequestTime;
      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
        await new Promise((resolve) => setTimeout(resolve, delayTime));
      }
      this.requestCount = 0;
    }
    this.lastRequestTime = Date.now();
  }
  async *[Symbol.asyncIterator]() {
    let hasMore = true;
    let offset = 0;
    while (hasMore) {
      await this.rateLimit();
      this.query.offset = offset;
      const items = await listKeys(this.config, this.query);
      for (const item of items) {
        yield item;
      }
      if (items.length === 0) {
        hasMore = false;
      } else {
        offset += items.length;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};
var Groups = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  create(options) {
    return createGroup(this.config, options);
  }
  list() {
    return new FilterGroups(this.config);
  }
  get(options) {
    return getGroup(this.config, options);
  }
  addCids(options) {
    return addToGroup(this.config, options);
  }
  removeCids(options) {
    return removeFromGroup(this.config, options);
  }
  update(options) {
    return updateGroup(this.config, options);
  }
  delete(options) {
    return deleteGroup(this.config, options);
  }
};
var FilterGroups = class {
  constructor(config) {
    this.query = {};
    // rate limit vars
    this.requestCount = 0;
    this.lastRequestTime = 0;
    this.MAX_REQUESTS_PER_MINUTE = 30;
    this.MINUTE_IN_MS = 6e4;
    this.config = config;
  }
  offset(offset) {
    this.query.offset = offset;
    return this;
  }
  name(nameContains) {
    this.query.nameContains = nameContains;
    return this;
  }
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  then(onfulfilled) {
    return listGroups(this.config, this.query).then(onfulfilled);
  }
  // rate limit, hopefully temporary?
  async rateLimit() {
    this.requestCount++;
    const now = Date.now();
    if (this.requestCount >= this.MAX_REQUESTS_PER_MINUTE) {
      const timePassedSinceLastRequest = now - this.lastRequestTime;
      if (timePassedSinceLastRequest < this.MINUTE_IN_MS) {
        const delayTime = this.MINUTE_IN_MS - timePassedSinceLastRequest;
        await new Promise((resolve) => setTimeout(resolve, delayTime));
      }
      this.requestCount = 0;
    }
    this.lastRequestTime = Date.now();
  }
  async *[Symbol.asyncIterator]() {
    let hasMore = true;
    let offset = 0;
    while (hasMore) {
      await this.rateLimit();
      this.query.offset = offset;
      const items = await listGroups(this.config, this.query);
      for (const item of items) {
        yield item;
      }
      if (items.length === 0) {
        hasMore = false;
      } else {
        offset += items.length;
      }
    }
  }
  async all() {
    const allItems = [];
    for await (const item of this) {
      allItems.push(item);
    }
    return allItems;
  }
};
var Signatures = class {
  constructor(config) {
    this.config = formatConfig(config);
  }
  add(options) {
    return addSignature(this.config, options);
  }
  get(cid) {
    return getSignature(this.config, cid);
  }
  delete(cid) {
    return removeSignature(this.config, cid);
  }
};
export {
  PinataSDK
};
//# sourceMappingURL=index.mjs.map